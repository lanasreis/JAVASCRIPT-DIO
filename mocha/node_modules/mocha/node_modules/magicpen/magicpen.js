/*!
 * Copyright (c) 2014 Sune Simonsen <sune@we-knowhow.dk>
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the 'Software'), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

(function (global, factory) {
            typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
            typeof define === 'function' && define.amd ? define(factory) :
            (global = global || self, (global.weknowhow = global.weknowhow || {}, global.weknowhow.MagicPen = factory()));
}(this, (function () {
            var global$1 = (typeof global !== "undefined" ? global :
                        typeof self !== "undefined" ? self :
                        typeof window !== "undefined" ? window : {});

            // shim for using process in browser
            // based off https://github.com/defunctzombie/node-process/blob/master/browser.js

            function defaultSetTimout() {
                throw new Error('setTimeout has not been defined');
            }
            function defaultClearTimeout () {
                throw new Error('clearTimeout has not been defined');
            }
            var cachedSetTimeout = defaultSetTimout;
            var cachedClearTimeout = defaultClearTimeout;
            if (typeof global$1.setTimeout === 'function') {
                cachedSetTimeout = setTimeout;
            }
            if (typeof global$1.clearTimeout === 'function') {
                cachedClearTimeout = clearTimeout;
            }

            function runTimeout(fun) {
                if (cachedSetTimeout === setTimeout) {
                    //normal enviroments in sane situations
                    return setTimeout(fun, 0);
                }
                // if setTimeout wasn't available but was latter defined
                if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
                    cachedSetTimeout = setTimeout;
                    return setTimeout(fun, 0);
                }
                try {
                    // when when somebody has screwed with setTimeout but no I.E. maddness
                    return cachedSetTimeout(fun, 0);
                } catch(e){
                    try {
                        // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                        return cachedSetTimeout.call(null, fun, 0);
                    } catch(e){
                        // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                        return cachedSetTimeout.call(this, fun, 0);
                    }
                }


            }
            function runClearTimeout(marker) {
                if (cachedClearTimeout === clearTimeout) {
                    //normal enviroments in sane situations
                    return clearTimeout(marker);
                }
                // if clearTimeout wasn't available but was latter defined
                if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
                    cachedClearTimeout = clearTimeout;
                    return clearTimeout(marker);
                }
                try {
                    // when when somebody has screwed with setTimeout but no I.E. maddness
                    return cachedClearTimeout(marker);
                } catch (e){
                    try {
                        // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                        return cachedClearTimeout.call(null, marker);
                    } catch (e){
                        // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                        // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                        return cachedClearTimeout.call(this, marker);
                    }
                }



            }
            var queue = [];
            var draining = false;
            var currentQueue;
            var queueIndex = -1;

            function cleanUpNextTick() {
                if (!draining || !currentQueue) {
                    return;
                }
                draining = false;
                if (currentQueue.length) {
                    queue = currentQueue.concat(queue);
                } else {
                    queueIndex = -1;
                }
                if (queue.length) {
                    drainQueue();
                }
            }

            function drainQueue() {
                if (draining) {
                    return;
                }
                var timeout = runTimeout(cleanUpNextTick);
                draining = true;

                var len = queue.length;
                while(len) {
                    currentQueue = queue;
                    queue = [];
                    while (++queueIndex < len) {
                        if (currentQueue) {
                            currentQueue[queueIndex].run();
                        }
                    }
                    queueIndex = -1;
                    len = queue.length;
                }
                currentQueue = null;
                draining = false;
                runClearTimeout(timeout);
            }
            function nextTick(fun) {
                var args = new Array(arguments.length - 1);
                if (arguments.length > 1) {
                    for (var i = 1; i < arguments.length; i++) {
                        args[i - 1] = arguments[i];
                    }
                }
                queue.push(new Item(fun, args));
                if (queue.length === 1 && !draining) {
                    runTimeout(drainQueue);
                }
            }
            // v8 likes predictible objects
            function Item(fun, array) {
                this.fun = fun;
                this.array = array;
            }
            Item.prototype.run = function () {
                this.fun.apply(null, this.array);
            };
            var title = 'browser';
            var platform = 'browser';
            var browser = true;
            var env = {};
            var argv = [];
            var version = ''; // empty string to avoid regexp issues
            var versions = {};
            var release = {};
            var config = {};

            function noop() {}

            var on = noop;
            var addListener = noop;
            var once = noop;
            var off = noop;
            var removeListener = noop;
            var removeAllListeners = noop;
            var emit = noop;

            function binding(name) {
                throw new Error('process.binding is not supported');
            }

            function cwd () { return '/' }
            function chdir (dir) {
                throw new Error('process.chdir is not supported');
            }function umask() { return 0; }

            // from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
            var performance = global$1.performance || {};
            var performanceNow =
              performance.now        ||
              performance.mozNow     ||
              performance.msNow      ||
              performance.oNow       ||
              performance.webkitNow  ||
              function(){ return (new Date()).getTime() };

            // generate timestamp or delta
            // see http://nodejs.org/api/process.html#process_process_hrtime
            function hrtime(previousTimestamp){
              var clocktime = performanceNow.call(performance)*1e-3;
              var seconds = Math.floor(clocktime);
              var nanoseconds = Math.floor((clocktime%1)*1e9);
              if (previousTimestamp) {
                seconds = seconds - previousTimestamp[0];
                nanoseconds = nanoseconds - previousTimestamp[1];
                if (nanoseconds<0) {
                  seconds--;
                  nanoseconds += 1e9;
                }
              }
              return [seconds,nanoseconds]
            }

            var startTime = new Date();
            function uptime() {
              var currentTime = new Date();
              var dif = currentTime - startTime;
              return dif / 1000;
            }

            var process = {
              nextTick: nextTick,
              title: title,
              browser: browser,
              env: env,
              argv: argv,
              version: version,
              versions: versions,
              on: on,
              addListener: addListener,
              once: once,
              off: off,
              removeListener: removeListener,
              removeAllListeners: removeAllListeners,
              emit: emit,
              binding: binding,
              cwd: cwd,
              chdir: chdir,
              umask: umask,
              hrtime: hrtime,
              platform: platform,
              release: release,
              config: config,
              uptime: uptime
            };

            function createCommonjsModule(fn, module) {
            	return module = { exports: {} }, fn(module, module.exports), module.exports;
            }

            var utils = {
                extend: function (target) {
                    for (var i = 1; i < arguments.length; i += 1) {
                        var source = arguments[i];
                        Object.keys(source).forEach(function (key) {
                            target[key] = source[key];
                        });
                    }
                    return target;
                },

                calculateOutputEntrySize: function (outputEntry) {
                    if (outputEntry.size) {
                        return outputEntry.size;
                    }

                    var size;
                    switch (outputEntry.style) {
                    case 'text':
                        size = { width: String(outputEntry.args.content).length, height: 1 };
                        break;
                    case 'block':
                        size = utils.calculateSize(outputEntry.args);
                        break;
                    case 'raw':
                        var arg = outputEntry.args;
                        size = { width: arg.width, height: arg.height };
                        break;
                    default: size = { width: 0, height: 0 };
                    }

                    outputEntry.size = size;
                    return size;
                },

                calculateLineSize: function (line) {
                    var size = { height: 1, width: 0 };
                    line.forEach(function (outputEntry) {
                        var outputEntrySize = utils.calculateOutputEntrySize(outputEntry);
                        size.width += outputEntrySize.width;
                        size.height = Math.max(outputEntrySize.height, size.height);
                    });
                    return size;
                },

                calculateSize: function (lines) {
                    var size = { height: 0, width: 0 };
                    lines.forEach(function (line) {
                        var lineSize = utils.calculateLineSize(line);
                        size.height += lineSize.height;
                        size.width = Math.max(size.width, lineSize.width);
                    });
                    return size;
                },

                arrayEquals: function (a, b) {
                    if (a === b) {
                        return true;
                    }

                    if (!a || a.length !== b.length) {
                        return false;
                    }

                    for (var i = 0; i < a.length; i += 1) {
                        if (a[i] !== b[i]) {
                            return false;
                        }
                    }

                    return true;

                },

                escapeRegExp: function (text){
                    return text.replace(/([.*+?^${}()|\[\]\/\\])/g, "\\$1");
                },

                findFirst: function (arr, predicate, thisObj) {
                    var scope = thisObj || null;
                    for (var i = 0 ; i < arr.length ; i += 1) {
                        if (predicate.call(scope, arr[i], i, arr)) {
                            return arr[i];
                        }
                    }
                    return null;
                },

                getFunctionName: function (f) {
                    if (typeof f.name === 'string') {
                        return f.name;
                    }
                    var matchFunctionName = Function.prototype.toString.call(f).match(/function ([^\(]+)/);
                    if (matchFunctionName) {
                        return matchFunctionName[1];
                    }

                    if (f === Object) {
                        return 'Object';
                    }
                    if (f === Function) {
                        return 'Function';
                    }
                }
            };

            var utils_1 = utils;

            var whitespaceCacheLength = 256;
            var whitespaceCache = [''];
            for (var i = 1; i <= whitespaceCacheLength; i += 1) {
                whitespaceCache[i] = whitespaceCache[i - 1] + ' ';
            }

            function duplicateText(content, times) {
                if (times < 0) {
                    return '';
                }

                var result = '';

                if (content === ' ') {
                    if (times <= whitespaceCacheLength) {
                        return whitespaceCache[times];
                    }

                    var segment = whitespaceCache[whitespaceCacheLength];
                    var numberOfSegments = Math.floor(times / whitespaceCacheLength);
                    for (var i = 0; i < numberOfSegments; i += 1) {
                        result += segment;
                    }
                    result += whitespaceCache[times % whitespaceCacheLength];
                } else {
                    for (var j = 0; j < times; j += 1) {
                        result += content;
                    }
                }

                return result;
            }

            var duplicateText_1 = duplicateText;

            var rgbRegexp =  /^(?:bg)?#(?:[0-9a-f]{3}|[0-9a-f]{6})$/i;

            var cssStyles = {
                bold: 'font-weight: bold',
                dim: 'opacity: 0.7',
                italic: 'font-style: italic',
                underline: 'text-decoration: underline',
                inverse: '-webkit-filter: invert(%100); filter: invert(100%)',
                hidden: 'visibility: hidden',
                strikeThrough: 'text-decoration: line-through',

                black: 'color: black',
                red: 'color: red',
                green: 'color: green',
                yellow: 'color: yellow',
                blue: 'color: blue',
                magenta: 'color: magenta',
                cyan: 'color: cyan',
                white: 'color: white',
                gray: 'color: gray',

                bgBlack: 'background-color: black',
                bgRed: 'background-color: red',
                bgGreen: 'background-color: green',
                bgYellow: 'background-color: yellow',
                bgBlue: 'background-color: blue',
                bgMagenta: 'background-color: magenta',
                bgCyan: 'background-color: cyan',
                bgWhite: 'background-color: white'
            };

            Object.keys(cssStyles).forEach(function (styleName) {
                cssStyles[styleName.toLowerCase()] = cssStyles[styleName];
            });

            var cssStyles_1 = cssStyles;

            /*globals Deno*/
            var isNode = !!(typeof process !== 'undefined' && process.versions && process.versions.node);

            var platform$1 = (function () {
                if (typeof Deno !== 'undefined') {
                    var env = {};
                    try {
                        env = Deno.env();
                    } catch (err) {
                      // Probably a permissions error because we don't have permission to read the environment variables
                      // Unfortunately the whole permissions API is async now:
                      // https://github.com/denoland/deno/pull/3200/files
                      // ... so we can't detect whether we do have access
                    }

                    return {
                        argv: Deno.args,
                        color: !Deno.noColor ? 1 : 0,
                        env: env,
                        runtime: 'deno'
                    };
                } else if (isNode) {
                    var os = require('os');

                    return {
                        argv: process.argv,
                        env: process.env,
                        runtime: 'node',
                        getNodeRelease: os.release
                    };
                } else {
                    return {
                        argv: [],
                        env: {},
                        runtime: 'browser'
                    };
                }
            })();

            // Fork from https://github.com/sindresorhus/has-flag
            var hasFlag = function hasFlag(flag, argv) {
              argv = argv || platform$1.argv;
              var prefix = flag.indexOf('-') === 0 ? '' : flag.length === 1 ? '-' : '--';
              var pos = argv.indexOf(prefix + flag);
              var terminatorPos = argv.indexOf('--');
              return pos !== -1 && (terminatorPos === -1 || pos < terminatorPos);
            };

            // Fork from https://github.com/chalk/supports-color
            var env$1 = platform$1.env;

            var forceColor;
            if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false') || hasFlag('color=never')) {
              forceColor = 0;
            } else if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) {
              forceColor = 1;
            } else if (platform$1.runtime === 'deno') {
              forceColor = platform$1.color;
            }

            if ('FORCE_COLOR' in env$1) {
              if (env$1.FORCE_COLOR === 'true') {
                forceColor = 1;
              } else if (env$1.FORCE_COLOR === 'false') {
                forceColor = 0;
              } else {
                forceColor = env$1.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env$1.FORCE_COLOR, 10), 3);
              }
            }

            function translateLevel(level) {
              if (level === 0) {
                return false;
              }

              return {
                level: level,
                hasBasic: true,
                has256: level >= 2,
                has16m: level >= 3
              };
            }

            function supportsColor(stream) {
              if (forceColor === 0) {
                return 0;
              }

              if (hasFlag('color=16m') || hasFlag('color=full') || hasFlag('color=truecolor')) {
                return 3;
              }

              if (hasFlag('color=256')) {
                return 2;
              }

              if (stream && !stream.isTTY && forceColor === undefined) {
                return 0;
              }

              var min = forceColor || 0;

              if (env$1.TERM === 'dumb') {
                return min;
              }

              if (platform$1.runtime === 'node' && process.platform === 'win32') {
                // Node.js 7.5.0 is the first version of Node.js to include a patch to
                // libuv that enables 256 color output on Windows. Anything earlier and it
                // won't work. However, here we target Node.js 8 at minimum as it is an LTS
                // release, and Node.js 7 is not. Windows 10 build 10586 is the first Windows
                // release that supports 256 colors. Windows 10 build 14931 is the first release
                // that supports 16m/TrueColor.
                var osRelease = platform$1.getNodeRelease().split('.');
                if (Number(process.versions.node.split('.')[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
                  return Number(osRelease[2]) >= 14931 ? 3 : 2;
                }

                return 1;
              }

              if ('CI' in env$1) {
                if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(function (sign) {
                  return sign in env$1;
                }) || env$1.CI_NAME === 'codeship') {
                  return 1;
                }

                return min;
              }

              if ('TEAMCITY_VERSION' in env$1) {
                return (/^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env$1.TEAMCITY_VERSION) ? 1 : 0
                );
              }

              if (env$1.COLORTERM === 'truecolor') {
                return 3;
              }

              if ('TERM_PROGRAM' in env$1) {
                var version = parseInt((env$1.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

                switch (env$1.TERM_PROGRAM) {
                  case 'iTerm.app':
                    return version >= 3 ? 3 : 2;
                  case 'Apple_Terminal':
                    return 2;
                  // No default
                }
              }

              if (/-256(color)?$/i.test(env$1.TERM)) {
                return 2;
              }

              if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env$1.TERM)) {
                return 1;
              }

              if ('COLORTERM' in env$1) {
                return 1;
              }

              return min;
            }

            function getSupportLevel(stream) {
              var level = supportsColor(stream);
              return translateLevel(level);
            }

            var supportsColor_1 = {
              supportsColor: getSupportLevel,
              stdout: getSupportLevel(process.stdout),
              stderr: getSupportLevel(process.stderr)
            };

            function createPadding(length, themes) {
                return {
                    style: 'text',
                    args: {
                        content: duplicateText_1(' ', length),
                        styles: []
                    },
                    themes: themes
                };
            }

            function lineContainsBlocks(line) {
                return line.some(function (outputEntry) {
                    return outputEntry.style === 'block' ||
                        (outputEntry.style === 'text' && String(outputEntry.args.content).indexOf('\n') !== -1);
                });
            }

            function flattenBlocksInOutputEntry(outputEntry) {
                switch (outputEntry.style) {
                case 'text': return String(outputEntry.args.content).split('\n').map(function (line) {
                    if (line === '') {
                        return [];
                    }

                    var args = { content: line, styles: outputEntry.args.styles };
                    return [{ style: 'text', args: args, themes: outputEntry.themes }];
                });
                case 'block': return flattenBlocksInLines(outputEntry.args);
                default: return [];
                }
            }

            function flattenBlocksInLine(line) {
                if (line.length === 0) {
                   return [[]];
                }

                if (!lineContainsBlocks(line)) {
                    return [line];
                }

                var result = [];
                var linesLengths = [];

                var startIndex = 0;
                line.forEach(function (outputEntry, blockIndex) {
                    var blockLines = flattenBlocksInOutputEntry(outputEntry);

                    var blockLinesLengths = blockLines.map(function (line) {
                        return utils_1.calculateLineSize(line).width;
                    });

                    var longestLineLength = Math.max.apply(null, blockLinesLengths);

                    blockLines.forEach(function (blockLine, index) {
                        var resultLine = result[index];

                        if (!resultLine) {
                            result[index] = resultLine = [];
                            linesLengths[index] = 0;
                        }

                        if (blockLine.length) {
                            var paddingLength = startIndex - linesLengths[index];
                            resultLine.push(createPadding(paddingLength, outputEntry.themes));
                            Array.prototype.push.apply(resultLine, blockLine);
                            linesLengths[index] = startIndex + blockLinesLengths[index];
                        }
                    });

                    startIndex += longestLineLength;
                }, this);
                return result;
            }

            function flattenBlocksInLines(lines) {
                var result = [];
                lines.forEach(function (line) {
                    flattenBlocksInLine(line).forEach(function (line) {
                        result.push(line);
                    });
                });
                return result;
            }

            var flattenBlocksInLines_1 = flattenBlocksInLines;

            function TextSerializer() {}

            TextSerializer.prototype.format = 'text';

            TextSerializer.prototype.serialize = function (lines) {
                lines = flattenBlocksInLines_1(lines);
                return lines.map(this.serializeLine, this).join('\n');
            };

            TextSerializer.prototype.serializeLine = function (line) {
                return line.map(function (outputEntry) {
                    return this[outputEntry.style] ?
                        String(this[outputEntry.style](outputEntry.args, outputEntry.themes)) :
                        '';
                }, this).join('');
            };

            TextSerializer.prototype.text = function (options) {
                return String(options.content);
            };

            TextSerializer.prototype.block = function (content) {
                return this.serialize(content);
            };

            TextSerializer.prototype.raw = function (options) {
                return String(options.content(this));
            };


            var TextSerializer_1 = TextSerializer;

            var themeMapper = function (theme, styles) {
                if (styles.length === 1) {
                    var count = 0;
                    var stack = [];
                    var themeMapping = styles[0];
                    var themeStyles = theme.styles || {};
                    while(typeof themeMapping === 'string' && themeStyles[themeMapping]) {
                        themeMapping = themeStyles[themeMapping];
                        count += 1;
                        if (count > 100) {
                            var index = stack.indexOf(themeMapping);
                            stack.push(themeMapping);
                            if (index !== -1) {
                                throw new Error('Your theme contains a loop: ' + stack.slice(index).join(' -> '));
                            }
                        }
                    }

                    return Array.isArray(themeMapping) ? themeMapping : [themeMapping];
                }

                return styles;
            };

            function HtmlSerializer() {}

            HtmlSerializer.prototype.format = 'html';

            HtmlSerializer.prototype.serialize = function (lines) {
                return '<div style="font-family: monospace; white-space: nowrap">' + this.serializeLines(lines) + '</div>';
            };

            HtmlSerializer.prototype.serializeLines = function (lines) {
                return lines.map(function (line) {
                    return '<div>' + (this.serializeLine(line).join('') || '&nbsp;') + '</div>';
                }, this).join('');
            };

            HtmlSerializer.prototype.serializeLine = function (line) {
                return line.map(function (outputEntry) {
                    return this[outputEntry.style] ?
                        this[outputEntry.style](outputEntry.args, outputEntry.themes) :
                        '';
                }, this);
            };

            HtmlSerializer.prototype.block = function (content) {
                return '<div style="display: inline-block; vertical-align: top">' +
                    this.serializeLines(content) +
                    '</div>';
            };

            HtmlSerializer.prototype.text = function (options, themes) {
                var content = String(options.content);

                if (content === '') {
                    return '';
                }

                content = content
                    .replace(/&/g, '&amp;')
                    .replace(/ /g, '&nbsp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;');

                var styles = themeMapper(themes.html || {}, options.styles);

                if (styles.length > 0) {
                    var styleProperties = [];
                    for (var j = 0; j < styles.length; j += 1) {
                        var styleName = styles[j];
                        if (rgbRegexp.test(styleName)) {
                            if (styleName.substring(0, 2) === 'bg') {
                                styleProperties.push('background-color: ' + styleName.substring(2));
                            } else {
                                styleProperties.push('color: ' + styleName);
                            }
                        } else if (cssStyles_1[styleName]) {
                            styleProperties.push(cssStyles_1[styleName]);
                        }

                    }

                    if (styleProperties.length > 0) {
                        content = '<span style="' + styleProperties.join('; ') + '">' + content + '</span>';
                    }
                }
                return content;
            };

            HtmlSerializer.prototype.raw = function (options) {
                return String(options.content(this));
            };

            var HtmlSerializer_1 = HtmlSerializer;

            /**
             * @author Markus Ekholm
             * @copyright 2012-2015 (c) Markus Ekholm <markus at botten dot org >
             * @license Copyright (c) 2012-2015, Markus Ekholm
             * All rights reserved.
             * Redistribution and use in source and binary forms, with or without
             * modification, are permitted provided that the following conditions are met:
             *    * Redistributions of source code must retain the above copyright
             *      notice, this list of conditions and the following disclaimer.
             *    * Redistributions in binary form must reproduce the above copyright
             *      notice, this list of conditions and the following disclaimer in the
             *      documentation and/or other materials provided with the distribution.
             *    * Neither the name of the <organization> nor the
             *      names of its contributors may be used to endorse or promote products
             *      derived from this software without specific prior written permission.
             *
             * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
             * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
             * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
             * DISCLAIMED. IN NO EVENT SHALL MARKUS EKHOLM BE LIABLE FOR ANY
             * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
             * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
             * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
             * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
             * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
             * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
             */

            /**
            * EXPORTS
            */
            var ciede2000_1 = ciede2000;

            /**
            * IMPORTS
            */
            var sqrt = Math.sqrt;
            var pow = Math.pow;
            var cos = Math.cos;
            var atan2 = Math.atan2;
            var sin = Math.sin;
            var abs = Math.abs;
            var exp = Math.exp;
            var PI = Math.PI;

            /**
             * API FUNCTIONS
             */

            /**
            * Returns diff between c1 and c2 using the CIEDE2000 algorithm
            * @param {labcolor} c1    Should have fields L,a,b
            * @param {labcolor} c2    Should have fields L,a,b
            * @return {float}   Difference between c1 and c2
            */
            function ciede2000(c1,c2)
            {
              /**
               * Implemented as in "The CIEDE2000 Color-Difference Formula:
               * Implementation Notes, Supplementary Test Data, and Mathematical Observations"
               * by Gaurav Sharma, Wencheng Wu and Edul N. Dalal.
               */

              // Get L,a,b values for color 1
              var L1 = c1.L;
              var a1 = c1.a;
              var b1 = c1.b;

              // Get L,a,b values for color 2
              var L2 = c2.L;
              var a2 = c2.a;
              var b2 = c2.b;

              // Weight factors
              var kL = 1;
              var kC = 1;
              var kH = 1;

              /**
               * Step 1: Calculate C1p, C2p, h1p, h2p
               */
              var C1 = sqrt(pow(a1, 2) + pow(b1, 2)); //(2)
              var C2 = sqrt(pow(a2, 2) + pow(b2, 2)); //(2)

              var a_C1_C2 = (C1+C2)/2.0;             //(3)

              var G = 0.5 * (1 - sqrt(pow(a_C1_C2 , 7.0) /
                                      (pow(a_C1_C2, 7.0) + pow(25.0, 7.0)))); //(4)

              var a1p = (1.0 + G) * a1; //(5)
              var a2p = (1.0 + G) * a2; //(5)

              var C1p = sqrt(pow(a1p, 2) + pow(b1, 2)); //(6)
              var C2p = sqrt(pow(a2p, 2) + pow(b2, 2)); //(6)

              var hp_f = function(x,y) //(7)
              {
                if(x== 0 && y == 0) return 0;
                else{
                  var tmphp = degrees(atan2(x,y));
                  if(tmphp >= 0) return tmphp
                  else           return tmphp + 360;
                }
              };

              var h1p = hp_f(b1, a1p); //(7)
              var h2p = hp_f(b2, a2p); //(7)

              /**
               * Step 2: Calculate dLp, dCp, dHp
               */
              var dLp = L2 - L1; //(8)
              var dCp = C2p - C1p; //(9)

              var dhp_f = function(C1, C2, h1p, h2p) //(10)
              {
                if(C1*C2 == 0)               return 0;
                else if(abs(h2p-h1p) <= 180) return h2p-h1p;
                else if((h2p-h1p) > 180)     return (h2p-h1p)-360;
                else if((h2p-h1p) < -180)    return (h2p-h1p)+360;
                else                         throw(new Error());
              };
              var dhp = dhp_f(C1,C2, h1p, h2p); //(10)
              var dHp = 2*sqrt(C1p*C2p)*sin(radians(dhp)/2.0); //(11)

              /**
               * Step 3: Calculate CIEDE2000 Color-Difference
               */
              var a_L = (L1 + L2) / 2.0; //(12)
              var a_Cp = (C1p + C2p) / 2.0; //(13)

              var a_hp_f = function(C1, C2, h1p, h2p) { //(14)
                if(C1*C2 == 0)                                      return h1p+h2p
                else if(abs(h1p-h2p)<= 180)                         return (h1p+h2p)/2.0;
                else if((abs(h1p-h2p) > 180) && ((h1p+h2p) < 360))  return (h1p+h2p+360)/2.0;
                else if((abs(h1p-h2p) > 180) && ((h1p+h2p) >= 360)) return (h1p+h2p-360)/2.0;
                else                                                throw(new Error());
              };
              var a_hp = a_hp_f(C1,C2,h1p,h2p); //(14)
              var T = 1-0.17*cos(radians(a_hp-30))+0.24*cos(radians(2*a_hp))+
                0.32*cos(radians(3*a_hp+6))-0.20*cos(radians(4*a_hp-63)); //(15)
              var d_ro = 30 * exp(-(pow((a_hp-275)/25,2))); //(16)
              var RC = sqrt((pow(a_Cp, 7.0)) / (pow(a_Cp, 7.0) + pow(25.0, 7.0)));//(17)
              var SL = 1 + ((0.015 * pow(a_L - 50, 2)) /
                            sqrt(20 + pow(a_L - 50, 2.0)));//(18)
              var SC = 1 + 0.045 * a_Cp;//(19)
              var SH = 1 + 0.015 * a_Cp * T;//(20)
              var RT = -2 * RC * sin(radians(2 * d_ro));//(21)
              var dE = sqrt(pow(dLp /(SL * kL), 2) + pow(dCp /(SC * kC), 2) +
                            pow(dHp /(SH * kH), 2) + RT * (dCp /(SC * kC)) *
                            (dHp / (SH * kH))); //(22)
              return dE;
            }

            /**
             * INTERNAL FUNCTIONS
             */
            function degrees(n) { return n*(180/PI); }
            function radians(n) { return n*(PI/180); }

            // Local Variables:
            // allout-layout: t
            // js-indent-level: 2
            // End:

            var diff = {
            	ciede2000: ciede2000_1
            };

            /**
             * @author Markus Ekholm
             * @copyright 2012-2015 (c) Markus Ekholm <markus at botten dot org >
             * @license Copyright (c) 2012-2015, Markus Ekholm
             * All rights reserved.
             * Redistribution and use in source and binary forms, with or without
             * modification, are permitted provided that the following conditions are met:
             *    * Redistributions of source code must retain the above copyright
             *      notice, this list of conditions and the following disclaimer.
             *    * Redistributions in binary form must reproduce the above copyright
             *      notice, this list of conditions and the following disclaimer in the
             *      documentation and/or other materials provided with the distribution.
             *    * Neither the name of the <organization> nor the
             *      names of its contributors may be used to endorse or promote products
             *      derived from this software without specific prior written permission.
             *
             * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
             * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
             * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
             * DISCLAIMED. IN NO EVENT SHALL MARKUS EKHOLM BE LIABLE FOR ANY
             * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
             * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
             * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
             * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
             * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
             * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
             */

            /**
            * EXPORTS
            */
            var rgb_to_lab_1 = rgb_to_lab;

            /**
            * IMPORTS
            */
            var pow$1  = Math.pow;

            /**
             * API FUNCTIONS
             */

            /**
            * Returns c converted to labcolor.
            * @param {rgbcolor} c should have fields R,G,B
            * @return {labcolor} c converted to labcolor
            */
            function rgb_to_lab(c)
            {
              return xyz_to_lab(rgb_to_xyz(c))
            }

            /**
            * Returns c converted to xyzcolor.
            * @param {rgbcolor} c should have fields R,G,B
            * @return {xyzcolor} c converted to xyzcolor
            */
            function rgb_to_xyz(c)
            {
              // Based on http://www.easyrgb.com/index.php?X=MATH&H=02
              var R = ( c.R / 255 );
              var G = ( c.G / 255 );
              var B = ( c.B / 255 );

              if ( R > 0.04045 ) R = pow$1(( ( R + 0.055 ) / 1.055 ),2.4);
              else               R = R / 12.92;
              if ( G > 0.04045 ) G = pow$1(( ( G + 0.055 ) / 1.055 ),2.4);
              else               G = G / 12.92;
              if ( B > 0.04045 ) B = pow$1(( ( B + 0.055 ) / 1.055 ), 2.4);
              else               B = B / 12.92;

              R *= 100;
              G *= 100;
              B *= 100;

              // Observer. = 2°, Illuminant = D65
              var X = R * 0.4124 + G * 0.3576 + B * 0.1805;
              var Y = R * 0.2126 + G * 0.7152 + B * 0.0722;
              var Z = R * 0.0193 + G * 0.1192 + B * 0.9505;
              return {'X' : X, 'Y' : Y, 'Z' : Z};
            }

            /**
            * Returns c converted to labcolor.
            * @param {xyzcolor} c should have fields X,Y,Z
            * @return {labcolor} c converted to labcolor
            */
            function xyz_to_lab(c)
            {
              // Based on http://www.easyrgb.com/index.php?X=MATH&H=07
              var ref_Y = 100.000;
              var ref_Z = 108.883;
              var ref_X = 95.047; // Observer= 2°, Illuminant= D65
              var Y = c.Y / ref_Y;
              var Z = c.Z / ref_Z;
              var X = c.X / ref_X;
              if ( X > 0.008856 ) X = pow$1(X, 1/3);
              else                X = ( 7.787 * X ) + ( 16 / 116 );
              if ( Y > 0.008856 ) Y = pow$1(Y, 1/3);
              else                Y = ( 7.787 * Y ) + ( 16 / 116 );
              if ( Z > 0.008856 ) Z = pow$1(Z, 1/3);
              else                Z = ( 7.787 * Z ) + ( 16 / 116 );
              var L = ( 116 * Y ) - 16;
              var a = 500 * ( X - Y );
              var b = 200 * ( Y - Z );
              return {'L' : L , 'a' : a, 'b' : b};
            }

            // Local Variables:
            // allout-layout: t
            // js-indent-level: 2
            // End:

            var convert = {
            	rgb_to_lab: rgb_to_lab_1
            };

            /**
             * @author Markus Ekholm
             * @copyright 2012-2015 (c) Markus Ekholm <markus at botten dot org >
             * @license Copyright (c) 2012-2015, Markus Ekholm
             * All rights reserved.
             * Redistribution and use in source and binary forms, with or without
             * modification, are permitted provided that the following conditions are met:
             *    * Redistributions of source code must retain the above copyright
             *      notice, this list of conditions and the following disclaimer.
             *    * Redistributions in binary form must reproduce the above copyright
             *      notice, this list of conditions and the following disclaimer in the
             *      documentation and/or other materials provided with the distribution.
             *    * Neither the name of the <organization> nor the
             *      names of its contributors may be used to endorse or promote products
             *      derived from this software without specific prior written permission.
             *
             * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
             * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
             * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
             * DISCLAIMED. IN NO EVENT SHALL MARKUS EKHOLM BE LIABLE FOR ANY
             * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
             * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
             * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
             * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
             * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
             * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
             */

            /**
            * EXPORTS
            */
            var map_palette_1     = map_palette;
            var palette_map_key_1 = palette_map_key;

            /**
            * IMPORTS
            */



            /**
             * API FUNCTIONS
             */

            /**
            * Returns the hash key used for a {rgbcolor} in a {palettemap}
            * @param {rgbcolor} c should have fields R,G,B
            * @return {string}
            */
            function palette_map_key(c)
            {
              return "R" + c.R + "B" + c.B + "G" + c.G;
            }

            /**
            * Returns a mapping from each color in a to the closest color in b
            * @param [{rgbcolor}] a each element should have fields R,G,B
            * @param [{rgbcolor}] b each element should have fields R,G,B
            * @param 'type' should be the string 'closest' or 'furthest'
            * @return {palettemap}
            */
            function map_palette(a, b, type)
            {
              var c = {};
              type = type || 'closest';
              for (var idx1 = 0; idx1 < a.length; idx1 += 1){
                var color1 = a[idx1];
                var best_color      = undefined;
                var best_color_diff = undefined;
                for (var idx2 = 0; idx2 < b.length; idx2 += 1)
                {
                  var color2 = b[idx2];
                  var current_color_diff = diff$1(color1,color2);

                  if((best_color == undefined) || ((type === 'closest') && (current_color_diff < best_color_diff)))
                  {
                    best_color      = color2;
                    best_color_diff = current_color_diff;
                    continue;
                  }
                  if((type === 'furthest') && (current_color_diff > best_color_diff))
                  {
                    best_color      = color2;
                    best_color_diff = current_color_diff;
                    continue;
                  }
                }
                c[palette_map_key(color1)] = best_color;
              }
              return c;
            }

            /**
             * INTERNAL FUNCTIONS
             */

            function diff$1(c1,c2)
            {
              c1 = convert.rgb_to_lab(c1);
              c2 = convert.rgb_to_lab(c2);
              return diff.ciede2000(c1,c2);
            }

            // Local Variables:
            // allout-layout: t
            // js-indent-level: 2
            // End:

            var palette = {
            	map_palette: map_palette_1,
            	palette_map_key: palette_map_key_1
            };

            var lib = createCommonjsModule(function (module) {





            var color = module.exports = {};

            color.diff             = diff.ciede2000;
            color.rgb_to_lab       = convert.rgb_to_lab;
            color.map_palette      = palette.map_palette;
            color.palette_map_key  = palette.palette_map_key;

            color.closest = function(target, relative) {
                var key = color.palette_map_key(target);

                var result = color.map_palette([target], relative, 'closest');

                return result[key];
            };

            color.furthest = function(target, relative) {
                var key = color.palette_map_key(target);

                var result = color.map_palette([target], relative, 'furthest');

                return result[key];
            };
            });

            var ansiStyles = createCommonjsModule(function (module) {

            var styles = module.exports = {
            	modifiers: {
            		reset: [0, 0],
            		bold: [1, 22], // 21 isn't widely supported and 22 does the same thing
            		dim: [2, 22],
            		italic: [3, 23],
            		underline: [4, 24],
            		inverse: [7, 27],
            		hidden: [8, 28],
            		strikethrough: [9, 29]
            	},
            	colors: {
            		black: [30, 39],
            		red: [31, 39],
            		green: [32, 39],
            		yellow: [33, 39],
            		blue: [34, 39],
            		magenta: [35, 39],
            		cyan: [36, 39],
            		white: [37, 39],
            		gray: [90, 39]
            	},
            	bgColors: {
            		bgBlack: [40, 49],
            		bgRed: [41, 49],
            		bgGreen: [42, 49],
            		bgYellow: [43, 49],
            		bgBlue: [44, 49],
            		bgMagenta: [45, 49],
            		bgCyan: [46, 49],
            		bgWhite: [47, 49]
            	}
            };

            // fix humans
            styles.colors.grey = styles.colors.gray;

            Object.keys(styles).forEach(function (groupName) {
            	var group = styles[groupName];

            	Object.keys(group).forEach(function (styleName) {
            		var style = group[styleName];

            		styles[styleName] = group[styleName] = {
            			open: '\u001b[' + style[0] + 'm',
            			close: '\u001b[' + style[1] + 'm'
            		};
            	});

            	Object.defineProperty(styles, groupName, {
            		value: group,
            		enumerable: false
            	});
            });
            });
            var ansiStyles_1 = ansiStyles.modifiers;
            var ansiStyles_2 = ansiStyles.colors;
            var ansiStyles_3 = ansiStyles.bgColors;

            var cacheSize = 0;
            var maxColorCacheSize = 1024;

            var ansiStyles$1 = utils_1.extend({}, ansiStyles);
            Object.keys(ansiStyles$1).forEach(function (styleName) {
                ansiStyles$1[styleName.toLowerCase()] = ansiStyles$1[styleName];
            });

            function AnsiSerializer() {}

            AnsiSerializer.prototype = new TextSerializer_1();

            AnsiSerializer.prototype.format = 'ansi';

            var colorPalettes = {
                16: {
                    '#000000': 'black',
                    '#ff0000': 'red',
                    '#00ff00': 'green',
                    '#ffff00': 'yellow',
                    '#0000ff': 'blue',
                    '#ff00ff': 'magenta',
                    '#00ffff': 'cyan',
                    '#ffffff': 'white',
                    '#808080': 'gray'
                },
                256: {}
            };

            var diffPalettes = {};

            function convertColorToObject(color) {
                if (color.length < 6) {
                    // Allow CSS shorthand
                    color = color.replace(/^#?([0-9a-f])([0-9a-f])([0-9a-f])$/i, '$1$1$2$2$3$3');
                }
                // Split color into red, green, and blue components
                var hexMatch = color.match(/^#?([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])$/i);
                if (hexMatch) {
                    return {
                        R: parseInt(hexMatch[1], 16),
                        G: parseInt(hexMatch[2], 16),
                        B: parseInt(hexMatch[3], 16)
                    };
                }
            }

            function toHexColor(colorObject) {
                var hexString = (Math.round(colorObject.R) * 0x10000 + Math.round(colorObject.G) * 0x100 + Math.round(colorObject.B)).toString(16);
                return '#' + ('00000'.substr(0, 6 - hexString.length)) + hexString;
            }

            function firstUp(text) {
                return text.substring(0, 1).toUpperCase() + text.substring(1);
            }

            diffPalettes[16] = Object.keys(colorPalettes[16]).map(convertColorToObject);
            diffPalettes['bg16'] = Object.keys(colorPalettes[16]).filter(function (color) {
                return color !== "#808080";
            }).map(convertColorToObject);
            diffPalettes[256] = [].concat(diffPalettes[16]);
            var nextAnsiColorNumber = 16;
            function registerNext256PaletteEntry(obj) {
                diffPalettes[256].push(obj);
                colorPalettes[256][toHexColor(obj)] = nextAnsiColorNumber;
                nextAnsiColorNumber += 1;
            }

            for (var r = 0 ; r < 6 ; r += 1) {
                for (var g = 0 ; g < 6 ; g += 1) {
                    for (var b = 0 ; b < 6 ; b += 1) {
                        registerNext256PaletteEntry({
                            R: Math.round(r * 256 / 6),
                            G: Math.round(g * 256 / 6),
                            B: Math.round(b * 256 / 6)
                        });
                    }
                }
            }

            [
                0x08, 0x12, 0x1c, 0x26, 0x30, 0x3a, 0x44, 0x4e, 0x58, 0x60, 0x66, 0x76,
                0x80, 0x8a, 0x94, 0x9e, 0xa8, 0xb2, 0xbc, 0xc6, 0xd0, 0xda, 0xe4, 0xee
            ].forEach(function (value) {
                registerNext256PaletteEntry({R: value, G: value, B: value});
            });

            AnsiSerializer.prototype.text = function (options, themes) {
                var content = String(options.content);
                if (content === '') {
                    return '';
                }

                var styles = themeMapper(themes.ansi || {}, options.styles);

                if (styles.length > 0) {
                    for (var i = styles.length -1; i >= 0; i -= 1) {
                        var styleName = styles[i];

                        if (ansiStyles$1[styleName]) {
                            content = ansiStyles$1[styleName].open + content + ansiStyles$1[styleName].close;
                        } else if (rgbRegexp.test(styleName)) {
                            var originalStyleName = styleName;
                            var isBackgroundColor = styleName.substring(0, 2) === 'bg';
                            var colorName = isBackgroundColor ? styleName.substring(2) : styleName;

                            var color16Hex = toHexColor(lib.closest(convertColorToObject(colorName),
                                                                          diffPalettes[isBackgroundColor ? 'bg16' : 16]));
                            var closestColor16 = colorPalettes[16][color16Hex];

                            var color256Hex = toHexColor(lib.closest(convertColorToObject(colorName), diffPalettes[256]));
                            var closest256ColorIndex = colorPalettes[256][color256Hex];

                            if (isBackgroundColor) {
                                styleName = 'bg' + firstUp(closestColor16);
                            } else {
                                styleName = closestColor16;
                            }

                            var open = ansiStyles$1[styleName].open;
                            var close = ansiStyles$1[styleName].close;
                            if (color16Hex !== color256Hex) {
                                open += '\x1b[' + (isBackgroundColor ? 48 : 38) + ';5;' + closest256ColorIndex + 'm';
                            }
                            if (cacheSize < maxColorCacheSize) {
                                ansiStyles$1[originalStyleName] = {open: open, close: close};
                                cacheSize += 1;
                            }

                            content = open + content + close;
                        }
                    }
                }

                return content;
            };

            var AnsiSerializer_1 = AnsiSerializer;

            function ColoredConsoleSerializer() {}

            ColoredConsoleSerializer.prototype.format = 'coloredConsole';

            ColoredConsoleSerializer.prototype.serialize = function (lines) {
                var formatString = '';
                var styleStrings = [];
                this.serializeLines(flattenBlocksInLines_1(lines)).forEach(function (entry) {
                    if (entry) {
                        formatString += entry[0];
                        if (entry.length > 1) {
                            styleStrings.push(entry[1]);
                        }
                    }
                });
                return [formatString].concat(styleStrings);
            };

            ColoredConsoleSerializer.prototype.serializeLines = function (lines) {
                var result = [];
                lines.forEach(function (line, i) {
                    if (i > 0) {
                        result.push(['%c\n ', '']);
                    }
                    Array.prototype.push.apply(result, this.serializeLine(line));
                }, this);
                return result;
            };

            ColoredConsoleSerializer.prototype.serializeLine = function (line) {
                var result = [];
                line.forEach(function (outputEntry) {
                    if (this[outputEntry.style]) {
                        result.push(this[outputEntry.style](outputEntry.args, outputEntry.themes));
                    }
                }, this);
                return result;
            };

            ColoredConsoleSerializer.prototype.block = function (content) {
                return this.serializeLines(content);
            };

            ColoredConsoleSerializer.prototype.text = function (options, themes) {
                var content = String(options.content);
                if (content === '') {
                    return '';
                }

                var styles = themeMapper(themes.coloredConsole || {}, options.styles);

                var result = ['%c' + content.replace(/%/g, '%%')];
                var styleProperties = [];

                if (styles.length > 0) {
                    for (var i = 0; i < styles.length; i += 1) {
                        var styleName = styles[i];
                        if (rgbRegexp.test(styleName)) {
                            if (styleName.substring(0, 2) === 'bg') {
                                styleProperties.push('background-color: ' + styleName.substring(2));
                            } else {
                                styleProperties.push('color: ' + styleName);
                            }
                        } else if (cssStyles_1[styleName]) {
                            styleProperties.push(cssStyles_1[styleName]);
                        }
                    }
                }
                result.push(styleProperties.join('; '));
                return result;
            };

            ColoredConsoleSerializer.prototype.raw = function (options) {
                return String(options.content(this));
            };

            var ColoredConsoleSerializer_1 = ColoredConsoleSerializer;

            var MagicPen_1 = createCommonjsModule(function (module, exports) {
            /*global window*/

            var extend = utils_1.extend;




            var builtInStyleNames = [
                'bold', 'dim', 'italic', 'underline', 'inverse', 'hidden',
                'strikeThrough', 'black', 'red', 'green', 'yellow', 'blue',
                'magenta', 'cyan', 'white', 'gray', 'bgBlack', 'bgRed',
                'bgGreen', 'bgYellow', 'bgBlue', 'bgMagenta', 'bgCyan',
                'bgWhite'
            ];

            function MagicPen(options) {
                if (!(this instanceof MagicPen)) {
                    return new MagicPen(options);
                }

                options = options || {};

                if (typeof options === "string") {
                    options = {format: options };
                }

                var indentationWidth = 'indentationWidth' in options ?
                    options.indentationWidth : 2;
                this.indentationWidth = Math.max(indentationWidth, 0);

                this.indentationLevel = 0;
                this.output = [[]];
                this.styles = Object.create(null);
                this.installedPlugins = [];
                // Ready to be cloned individually:
                this._themes = {};
                Object.keys(MagicPen.serializers).forEach(function (serializerName) {
                    this._themes[serializerName] = { styles: {} };
                }, this);
                this.preferredWidth =  80;
                if (options.format) {
                    this.format = options.format;
                }
            }

            if ( typeof exports.nodeName !== 'string' && supportsColor_1.stdout) {
                MagicPen.defaultFormat = 'ansi';
            } else if (typeof window !== 'undefined' && typeof window.navigator !== 'undefined') {
                if (window._phantom || window.mochaPhantomJS || (window.__karma__ && window.__karma__.config.captureConsole)) {
                    MagicPen.defaultFormat = 'ansi'; // colored console
                } else {
                    MagicPen.defaultFormat = 'html'; // Browser
                }
            } else {
                MagicPen.defaultFormat = 'text'; // Plain text
            }

            MagicPen.prototype.newline = MagicPen.prototype.nl = function (count) {
                if (typeof count === 'undefined') {
                    count = 1;
                }

                if (count === 0) {
                    return this;
                }

                for (var i = 0; i < count; i += 1) {
                    this.output.push([]);
                }
                return this;
            };

            MagicPen.serializers = {};
            [
                TextSerializer_1,
                HtmlSerializer_1,
                AnsiSerializer_1,
                ColoredConsoleSerializer_1
            ].forEach(function (serializer) {
                MagicPen.serializers[serializer.prototype.format] = serializer;
            });

            function hasSameTextStyling(a, b) {
                if (!a || !b || a.style !== 'text' || b.style !== 'text') {
                    return false;
                }

                return utils_1.arrayEquals(a.args.styles, b.args.styles) && a.themes === b.themes;
            }

            function normalizeLine(line) {
                if (line.length === 0) {
                    return line;
                }

                var result = [line[0]];
                for (var i = 1; i < line.length; i += 1) {
                    var lastEntry = result[result.length - 1];
                    var entry = line[i];
                    if (entry.style === 'text' && entry.args.content === '') {
                        continue;
                    }
                    if (hasSameTextStyling(lastEntry, entry)) {
                        result[result.length - 1] = {
                            style: lastEntry.style,
                            args: {
                                content: lastEntry.args.content + entry.args.content,
                                styles: lastEntry.args.styles
                            },
                            themes: lastEntry.themes
                        };
                    } else {
                        result.push(entry);
                    }
                }

                return result;
            }

            MagicPen.prototype.write = function (options) {
                if (this.styles[options.style]) {
                    this.styles[options.style].apply(this, options.args);
                    return this;
                }
                var lastLine = this.output[this.output.length - 1];
                var lastEntry = lastLine[lastLine.length - 1];
                if (hasSameTextStyling(lastEntry, options)) {
                    lastLine[lastLine.length - 1] = {
                        style: lastEntry.style,
                        args: {
                            content: lastEntry.args.content + options.args.content,
                            styles: lastEntry.args.styles
                        },
                        themes: this._themes
                    };
                } else {
                    lastLine.push(options);
                }

                return this;
            };

            MagicPen.prototype.indentLines = function () {
                this.indentationLevel += 1;
                return this;
            };

            MagicPen.prototype.indent = MagicPen.prototype.i = function () {
                for (var i = 0; i < this.indentationLevel; i += 1) {
                    this.space(this.indentationWidth);
                }
                return this;
            };

            MagicPen.prototype.outdentLines = function () {
                this.indentationLevel = Math.max(0, this.indentationLevel - 1);
                return this;
            };

            MagicPen.prototype.addStyle = function (style, handler, allowRedefinition) {
                if (this[style] === false || ((this.hasOwnProperty(style) || MagicPen.prototype[style]) && !Object.prototype.hasOwnProperty.call(this.styles, style) && builtInStyleNames.indexOf(style) === -1)) {
                    throw new Error('"' + style + '" style cannot be defined, it clashes with a built-in attribute');
                }

                // Refuse to redefine a built-in style or a style already defined directly on this pen unless allowRedefinition is true:
                if (this.hasOwnProperty(style) || builtInStyleNames.indexOf(style) !== -1) {
                    var existingType = typeof this[style];
                    if (existingType === 'function') {
                        if (!allowRedefinition) {
                            throw new Error('"' + style + '" style is already defined, set 3rd arg (allowRedefinition) to true to define it anyway');
                        }
                    }
                }
                if (this._stylesHaveNotBeenClonedYet) {
                    this.styles = Object.create(this.styles);
                    this._stylesHaveNotBeenClonedYet = false;
                }

                this.styles[style] = handler;
                this[style] = function () {
                    handler.apply(this, arguments);
                    return this;
                };
                return this;
            };

            MagicPen.prototype.toString = function (format) {
                if (format && this.format && format !== this.format) {
                    throw new Error('A pen with format: ' + this.format + ' cannot be serialized to: ' + format);
                }

                format = this.format || format || 'text';
                if (format === 'auto') {
                    format = MagicPen.defaultFormat;
                }
                var theme = this._themes[format] || {};
                var serializer = new MagicPen.serializers[format]();
                return serializer.serialize(this.output);
            };

            MagicPen.prototype.text = function () {
                var content = arguments[0];
                if (content === '') {
                    return this;
                }

                var styles = new Array(arguments.length - 1);
                for (var i = 1; i < arguments.length; i += 1) {
                    styles[i - 1] = arguments[i];
                }

                content = String(content);
                if (content.indexOf('\n') !== -1) {
                    var lines = content.split(/\n/);
                    lines.forEach(function (lineContent, index) {
                        if (lineContent.length) {
                            this.write({
                                style: 'text',
                                args: { content: lineContent, styles: styles },
                                themes: this._themes
                            });
                        }
                        if (index < lines.length - 1) {
                            this.nl();
                        }
                    }, this);
                    return this;
                } else {
                    return this.write({
                        style: 'text',
                        args: { content: content, styles: styles },
                        themes: this._themes
                    });
                }
            };

            MagicPen.prototype.removeFormatting = function () {
                var result = this.clone();
                this.output.forEach(function (line, index) {
                    result.output[index] = normalizeLine(line.map(function (outputEntry) {
                        return outputEntry.style === 'text' ?
                            { style: 'text', args: { content: outputEntry.args.content, styles: [] }, themes: outputEntry.themes } :
                            outputEntry;
                    }));
                });
                result.indentationLevel = this.indentationLevel;
                return result;
            };

            MagicPen.prototype.getContentFromArguments = function (args) {
                var clone;
                if (args[0].isMagicPen) {
                    this.ensureCompatibleFormat(args[0].format);
                    return args[0];
                } else if (typeof args[0] === 'function') {
                    clone = this.clone();
                    args[0].call(clone, clone);
                    return clone;
                } else if (typeof args[0] === 'string' && args.length === 1) {
                    clone = this.clone();
                    clone.text(args[0]);
                    return clone;
                } else if (typeof args[0] === 'string') {
                    clone = this.clone();
                    clone[args[0]].apply(clone, Array.prototype.slice.call(args, 1));
                    return clone;
                } else {
                    throw new Error('Requires the arguments to be:\n' +
                                    'a pen or\n' +
                                    'a callback appending content to a pen or\n' +
                                    'a style and arguments for that style or\n' +
                                    'just a string.');
                }
            };

            MagicPen.prototype.isMultiline = function () {
                return this.output.length > 1 || this.size().height > 1;
            };

            MagicPen.prototype.isAtStartOfLine = function () {
                return this.output.length === 0 || this.output[this.output.length - 1].length === 0;
            };

            MagicPen.prototype.isBlock = function () {
                return this.output.length === 1 &&
                    this.output[0].length === 1 &&
                    this.output[0][0].style === 'block';
            };

            MagicPen.prototype.ensureCompatibleFormat = function (format) {
                if (format && this.format && format !== this.format) {
                    throw new Error('This pen is only compatible with the format: ' + this.format);
                }
            };

            MagicPen.prototype.block = function () {
                var pen = this.getContentFromArguments(arguments);

                var blockOutput = pen.output.map(function (line) {
                    return [].concat(line);
                });
                return this.write({ style: 'block', args: blockOutput, themes: this._themes });
            };

            function isRawOutput(options) {
                return options &&
                    typeof options === 'object' &&
                    typeof options.width === 'number' &&
                    typeof options.height === 'number' && (
                        typeof options.content === 'function' ||
                            typeof options.content === 'string'
                    );
            }

            MagicPen.prototype.alt = function (options) {
                var format = this.format;
                if (!format) {
                    throw new Error('The alt method is only supported on a pen where the format has already been set');
                }

                var outputProperty = options[format];

                if (typeof outputProperty === 'undefined') {
                    if (options.fallback) {
                        return this.append(options.fallback);
                    } else {
                        // Nothing to do for this format, just NOOP:
                        return this;
                    }
                }

                if (typeof outputProperty === 'string' || isRawOutput(outputProperty)) {
                    return this.raw(outputProperty);
                } else {
                    return this.append(outputProperty);
                }
            };

            MagicPen.prototype.raw = function (options) {
                var format = this.format;
                if (!format) {
                    throw new Error('The raw method is only supported on a pen where the format has already been set');
                }

                if (typeof options === 'string') {
                    return this.write({
                        style: 'raw',
                        args: {
                            height: 0,
                            width: 0,
                            content: function () {
                                return options;
                            }
                        },
                        themes: this._themes
                    });
                }

                if (isRawOutput(options)) {
                    if (typeof options.content === 'string') {
                        options = extend({}, options);
                        var content = options.content;
                        options.content = function () {
                            return content;
                        };
                    }

                    return this.write({ style: 'raw', args: options, themes: this._themes });
                }

                throw new Error('Raw ' + this.format + ' content needs to adhere to one of the following forms:\n' +
                                'a string of raw content\n' +
                                'a function returning a string of raw content or\n' +
                                'an object with the following form { width: <number>, height: <number>, content: <string function() {}|string> }');
            };

            function amend(output, pen) {
                var lastLine = output[output.length - 1].slice();
                var newOutput = output.slice(0, -1);
                var lastEntry = lastLine[lastLine.length - 1];
                if (lastEntry && lastEntry.style === 'block') {
                    lastLine[lastLine.length - 1] = {
                        style: 'block',
                        args: amend(lastEntry.args, pen),
                        themes: pen._themes
                    };
                    newOutput[output.length - 1] = lastLine;
                } else {
                    Array.prototype.push.apply(lastLine, pen.output[0]);
                    newOutput[output.length - 1] = normalizeLine(lastLine);
                    newOutput.push.apply(newOutput, pen.output.slice(1));
                }

                return newOutput;
            }

            MagicPen.prototype.amend = function () {
                var pen = this.getContentFromArguments(arguments);

                if (pen.isEmpty()) {
                    return this;
                }

                this.output = amend(this.output, pen);

                return this;
            };

            MagicPen.prototype.append = function () {
                var pen = this.getContentFromArguments(arguments);

                if (pen.isEmpty()) {
                    return this;
                }

                var lastLine = this.output[this.output.length - 1];
                Array.prototype.push.apply(lastLine, pen.output[0]);
                this.output[this.output.length - 1] = normalizeLine(lastLine);

                this.output.push.apply(this.output, pen.output.slice(1));

                return this;
            };

            MagicPen.prototype.prependLinesWith = function () {
                var pen = this.getContentFromArguments(arguments);

                if (pen.isEmpty()) {
                    return this;
                }

                if (pen.output.length > 1) {
                    throw new Error('PrependLinesWith only supports a pen with single line content');
                }

                var height = this.size().height;
                var output = this.clone();
                output.block(function () {
                    for (var i = 0; i < height; i += 1) {
                        if (i > 0) {
                            this.nl();
                        }
                        this.append(pen);
                    }
                });
                output.block(this);

                this.output = output.output;
                return this;
            };

            MagicPen.prototype.space = MagicPen.prototype.sp = function (count) {
                if (count === 0) {
                    return this;
                }

                if (typeof count === 'undefined') {
                    count = 1;
                }

                return this.text(duplicateText_1(' ', count));
            };

            builtInStyleNames.forEach(function (textStyle) {
                MagicPen.prototype[textStyle] = MagicPen.prototype[textStyle.toLowerCase()] = function (content) {
                    return this.text(content, textStyle);
                };
            });

            MagicPen.prototype.clone = function (format) {
                if (!this.isEmpty()) {
                    this.ensureCompatibleFormat(format);
                }

                function MagicPenClone() {}
                MagicPenClone.prototype = this;
                var clonedPen = new MagicPenClone();
                clonedPen.styles = this.styles;
                clonedPen._stylesHaveNotBeenClonedYet = true;
                clonedPen.indentationLevel = 0;
                clonedPen.output = [[]];
                clonedPen.installedPlugins = [];
                clonedPen._themes = this._themes;
                clonedPen._themesHaveNotBeenClonedYet = true;
                clonedPen.format = format || this.format;
                clonedPen.parent = this;
                return clonedPen;
            };

            MagicPen.prototype.isMagicPen = true;

            MagicPen.prototype.size = function () {
                return utils_1.calculateSize(this.output);
            };

            MagicPen.prototype.use = function (plugin) {
                var existingPlugin = utils_1.findFirst(this.installedPlugins, function (installedPlugin) {
                    if (installedPlugin === plugin) {
                        return true;
                    } else if (typeof plugin === 'function' && typeof installedPlugin === 'function') {
                        var pluginName = utils_1.getFunctionName(plugin);
                        return pluginName !== '' && pluginName === utils_1.getFunctionName(installedPlugin);
                    } else {
                        return installedPlugin.name === plugin.name;
                    }
                });

                if (existingPlugin) {
                    if (existingPlugin === plugin || (typeof plugin.version !== 'undefined' && plugin.version === existingPlugin.version)) {
                        // No-op
                        return this;
                    } else {
                        throw new Error("Another instance of the plugin '" + plugin.name + "' " +
                                        "is already installed" +
                                        (typeof existingPlugin.version !== 'undefined' ?
                                            ' (version ' + existingPlugin.version +
                                            (typeof plugin.version !== 'undefined' ?
                                                ', trying to install ' + plugin.version : '') +
                                            ')' : '') +
                                        ". Please check your node_modules folder for unmet peerDependencies.");
                    }
                }

                if ((typeof plugin !== 'function' && (typeof plugin !== 'object' || typeof plugin.installInto !== 'function')) ||
                    (typeof plugin.name !== 'undefined' && typeof plugin.name !== 'string') ||
                    (typeof plugin.dependencies !== 'undefined' && !Array.isArray(plugin.dependencies))) {
                    throw new Error('Plugins must be functions or adhere to the following interface\n' +
                                    '{\n' +
                                    '  name: <an optional plugin name>,\n' +
                                    '  version: <an optional semver version string>,\n' +
                                    '  dependencies: <an optional list of dependencies>,\n' +
                                    '  installInto: <a function that will update the given magicpen instance>\n' +
                                    '}');
                }

                if (plugin.dependencies) {
                    var instance = this;
                    var thisAndParents = [];
                    do {
                        thisAndParents.push(instance);
                        instance = instance.parent;
                    } while (instance);
                    var unfulfilledDependencies = plugin.dependencies.filter(function (dependency) {
                        return !thisAndParents.some(function (instance) {
                            return instance.installedPlugins.some(function (plugin) {
                                return plugin.name === dependency;
                            });
                        });
                    });

                    if (unfulfilledDependencies.length === 1) {
                        throw new Error(plugin.name + ' requires plugin ' + unfulfilledDependencies[0]);
                    } else if (unfulfilledDependencies.length > 1) {
                        throw new Error(plugin.name + ' requires plugins ' +
                                        unfulfilledDependencies.slice(0, -1).join(', ') +
                                        ' and ' + unfulfilledDependencies[unfulfilledDependencies.length - 1]);
                    }
                }

                this.installedPlugins.push(plugin);
                if (typeof plugin === 'function') {
                    plugin(this);
                } else {
                    plugin.installInto(this);
                }

                return this; // for chaining
            };

            MagicPen.prototype.installPlugin = MagicPen.prototype.use; // Legacy alias

            function replaceText(output, outputArray, regexp, cb) {
                var replacedOutput = output;
                outputArray.forEach(function (line, i) {
                    if (i > 0) {
                        replacedOutput.nl();
                    }

                    line.forEach(function (outputEntry, j) {
                        if (outputEntry.style === 'block') {
                            return replacedOutput.output[replacedOutput.output.length - 1].push({
                                style: 'block',
                                args: replaceText(output.clone(), outputEntry.args, regexp, cb),
                                themes: outputEntry.themes
                            });
                        } else if (outputEntry.style !== 'text') {
                            return replacedOutput.output[replacedOutput.output.length - 1].push(outputEntry);
                        }

                        if (regexp.global) {
                            regexp.lastIndex = 0;
                        }
                        var m;
                        var first = true;
                        var lastIndex = 0;
                        var text = outputEntry.args.content;
                        var styles = outputEntry.args.styles;
                        while ((m = regexp.exec(text)) !== null && (regexp.global || first)) {
                            if (lastIndex < m.index) {
                                replacedOutput.text.apply(replacedOutput, [text.substring(lastIndex, m.index)].concat(styles));
                            }

                            cb.apply(replacedOutput, [styles].concat(m));
                            first = false;
                            lastIndex = m.index + m[0].length;
                        }

                        if (lastIndex === 0) {
                            var lastLine;
                            if (replacedOutput.output.length === 0) {
                                lastLine = replacedOutput.output[0] = [];
                            } else {
                                lastLine = replacedOutput.output[replacedOutput.output.length - 1];
                            }

                            lastLine.push(outputEntry);
                        } else if (lastIndex < text.length) {
                            replacedOutput.text.apply(replacedOutput, [text.substring(lastIndex, text.length)].concat(styles));
                        }
                    }, this);
                }, this);

                return replacedOutput.output.map(normalizeLine);
            }

            MagicPen.prototype.isEmpty = function () {
                return this.output.length === 1 && this.output[0].length === 0;
            };

            MagicPen.prototype.replaceText = function (regexp, cb) {
                if (this.isEmpty()) {
                    return this;
                }

                if (typeof regexp === 'string') {
                    regexp = new RegExp(utils_1.escapeRegExp(regexp), 'g');
                }

                if (typeof cb === 'string') {
                    var text = cb;
                    cb = function (styles, _) {
                        var args = [text].concat(styles);
                        this.text.apply(this, args);
                    };
                }


                if (arguments.length === 1) {
                    cb = regexp;
                    regexp = /.*/;
                }

                this.output = replaceText(this.clone(), this.output, regexp, cb);

                return this;
            };

            MagicPen.prototype.theme = function (format) {
                format = format || this.format;
                if (!format) {
                    throw new Error("Could not detect which format you want to retrieve " +
                                    "theme information for. Set the format of the pen or " +
                                    "provide it as an argument to the theme method.");
                }

                return this._themes[format];
            };

            MagicPen.prototype.installTheme = function (formats, theme) {
                var that = this;
                if (arguments.length === 1) {
                    theme = formats;
                    formats = Object.keys(MagicPen.serializers);
                }

                if (typeof formats === 'string') {
                    formats = [formats];
                }

                if (
                    typeof theme !== 'object' ||
                    !Array.isArray(formats) ||
                    formats.some(function (format) {
                        return typeof format !== 'string';
                    })
                ) {
                    throw new Error("Themes must be installed the following way:\n" +
                                    "Install theme for all formats: pen.installTheme({ comment: 'gray' })\n" +
                                    "Install theme for a specific format: pen.installTheme('ansi', { comment: 'gray' }) or\n" +
                                    "Install theme for a list of formats: pen.installTheme(['ansi', 'html'], { comment: 'gray' })");
                }

                if (!theme.styles || typeof theme.styles !== 'object') {
                    theme = {
                        styles: theme
                    };
                }

                if (that._themesHaveNotBeenClonedYet) {
                    var clonedThemes = {};
                    Object.keys(that._themes).forEach(function (format) {
                        clonedThemes[format] = Object.create(that._themes[format]);
                    });
                    that._themes = clonedThemes;
                    that._themesHaveNotBeenClonedYet = false;
                }

                Object.keys(theme.styles).forEach(function (themeKey) {
                    if (rgbRegexp.test(themeKey) || cssStyles_1[themeKey]) {
                        throw new Error("Invalid theme key: '" + themeKey + "' you can't map build styles.");
                    }

                    if (!that[themeKey]) {
                        that.addStyle(themeKey, function (content) {
                            this.text(content, themeKey);
                        });
                    }
                });

                formats.forEach(function (format) {
                    var baseTheme = that._themes[format] || { styles: {} };
                    var extendedTheme = extend({}, baseTheme, theme);
                    extendedTheme.styles = extend({}, baseTheme.styles, theme.styles);
                    that._themes[format] = extendedTheme;
                });


                return this;
            };

            module.exports = MagicPen;
            });

            return MagicPen_1;

})));
