(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.unexpectedEventEmitter = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
module.exports={
  "version": "2.2.0"
}
},{}],2:[function(require,module,exports){
'use strict';

var ref = require('../package.json');
var version = ref.version;

module.exports = {
  name: 'unexpected-eventemitter',
  version: version,
  installInto: function installInto(expect) {
    expect.addType({
      base: 'object',
      name: 'EventEmitter',
      identify: function (obj) { return obj !== null &&
        typeof obj === 'object' &&
        typeof obj.emit === 'function' &&
        typeof obj.once === 'function' &&
        typeof obj.on === 'function'; },
    });

    expect
      .addAssertion(
        '<function> [not] to emit from <EventEmitter> <string> <any*>',
        function (expect, subject, ee, eventName) {
          var values = [], len = arguments.length - 4;
          while ( len-- > 0 ) values[ len ] = arguments[ len + 4 ];

          var emitted = false;
          var emittedValues;
          // expect.errorMode = 'bubble';

          var onEvent = function () {
            var values = [], len = arguments.length;
            while ( len-- ) values[ len ] = arguments[ len ];

            emitted = true;
            emittedValues = values;
          };

          ee.once(eventName, onEvent);

          return expect
            .promise(function () {
              expect.errorMode = 'bubble';
              return expect(subject, 'not to error');
            })
            .then(function () {
              expect.errorMode = 'default';
              expect(emitted, '[not] to be true');
              expect.errorMode = 'nested';
              values.forEach(function (value, idx) {
                expect(emittedValues[idx], '[not] to satisfy', value);
              });
            })
            .finally(function () {
              ee.removeListener(eventName, onEvent);
            });
        }
      )
      .addAssertion(
        '<function> to emit with error from <Error> <EventEmitter> <string> <any*>',
        function (expect, subject, error, ee, eventName) {
          var values = [], len = arguments.length - 5;
          while ( len-- > 0 ) values[ len ] = arguments[ len + 5 ];

          var emitted = false;
          var emittedValues;

          var onEvent = function () {
            var values = [], len = arguments.length;
            while ( len-- ) values[ len ] = arguments[ len ];

            emitted = true;
            emittedValues = values;
          };

          ee.once(eventName, onEvent);

          return expect
            .promise(function () {
              expect.errorMode = 'bubble';
              return expect(subject, 'to error with', error);
            })
            .then(function () {
              expect.errorMode = 'default';
              expect(emitted, 'to be true');
              expect.errorMode = 'nested';
              values.forEach(function (value, idx) {
                expect(emittedValues[idx], 'to satisfy', value);
              });
            })
            .finally(function () {
              ee.removeListener(eventName, onEvent);
            });
        }
      );
  },
};

},{"../package.json":1}]},{},[2])(2)
});

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJwYWNrYWdlLmpzb24iLCIvVXNlcnMvYm9uZXNrdWxsL3Byb2plY3RzL2JvbmVza3VsbC91bmV4cGVjdGVkLWV2ZW50ZW1pdHRlci9zcmMvdW5leHBlY3RlZC1ldmVudGVtaXR0ZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7O0FDRkEsWUFBWSxDQUFDOztBQUViLE9BQWUsR0FBRyxPQUFPLENBQUMsaUJBQWlCO0FBQXBDLDBCQUFzQzs7QUFFN0MsTUFBTSxDQUFDLE9BQU8sR0FBRztFQUNmLElBQUksRUFBRSx5QkFBeUI7V0FDL0IsT0FBTztFQUNQLGlDQUFXLENBQUMsTUFBTSxFQUFFO0lBQ2xCLE1BQU0sQ0FBQyxPQUFPLENBQUM7TUFDYixJQUFJLEVBQUUsUUFBUTtNQUNkLElBQUksRUFBRSxjQUFjO01BQ3BCLFFBQVEsV0FBRSxDQUFDLEdBQUcsRUFBRSxTQUNkLEdBQUcsS0FBSyxJQUFJO1FBQ1osT0FBTyxHQUFHLEtBQUssUUFBUTtRQUN2QixPQUFPLEdBQUcsQ0FBQyxJQUFJLEtBQUssVUFBVTtRQUM5QixPQUFPLEdBQUcsQ0FBQyxJQUFJLEtBQUssVUFBVTtRQUM5QixPQUFPLEdBQUcsQ0FBQyxFQUFFLEtBQUssYUFBVTtLQUMvQixDQUFDLENBQUM7O0lBRUgsTUFBTTtPQUNILFlBQVk7UUFDWCw4REFBOEQ7aUJBQzlELENBQUMsTUFBTSxFQUFFLE9BQU8sRUFBRSxFQUFFLEVBQUUsU0FBUyxBQUFXLEVBQUUsQUFBRzs7O0FBQUM7VUFDOUMsR0FBRyxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUM7VUFDcEIsR0FBRyxDQUFDLGFBQWEsQ0FBQzs7O1VBR2xCLEdBQUssQ0FBQyxPQUFPLFlBQUcsQ0FBQyxBQUFTLEVBQUUsQUFBRzs7O0FBQUM7WUFDOUIsT0FBTyxHQUFHLElBQUksQ0FBQztZQUNmLGFBQWEsR0FBRyxNQUFNLENBQUM7V0FDeEIsQ0FBQzs7VUFFRixFQUFFLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQzs7VUFFNUIsT0FBTyxNQUFNO2FBQ1YsT0FBTyxVQUFDLEdBQUcsQUFBRztjQUNiLE1BQU0sQ0FBQyxTQUFTLEdBQUcsUUFBUSxDQUFDO2NBQzVCLE9BQU8sTUFBTSxDQUFDLE9BQU8sRUFBRSxjQUFjLENBQUMsQ0FBQzthQUN4QyxDQUFDO2FBQ0QsSUFBSSxVQUFDLEdBQUcsQUFBRztjQUNWLE1BQU0sQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFDO2NBQzdCLE1BQU0sQ0FBQyxPQUFPLEVBQUUsa0JBQWtCLENBQUMsQ0FBQztjQUNwQyxNQUFNLENBQUMsU0FBUyxHQUFHLFFBQVEsQ0FBQztjQUM1QixNQUFNLENBQUMsT0FBTyxVQUFDLENBQUMsS0FBSyxFQUFFLEdBQUcsRUFBRSxBQUFHO2dCQUM3QixNQUFNLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxFQUFFLGtCQUFrQixFQUFFLEtBQUssQ0FBQyxDQUFDO2VBQ3ZELENBQUMsQ0FBQzthQUNKLENBQUM7YUFDRCxPQUFPLFVBQUMsR0FBRyxBQUFHO2NBQ2IsRUFBRSxDQUFDLGNBQWMsQ0FBQyxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUM7YUFDdkMsQ0FBQyxDQUFDO1NBQ047T0FDRjtPQUNBLFlBQVk7UUFDWCwyRUFBMkU7aUJBQzNFLENBQUMsTUFBTSxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsRUFBRSxFQUFFLFNBQVMsQUFBVyxFQUFFLEFBQUc7OztBQUFDO1VBQ3JELEdBQUcsQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO1VBQ3BCLEdBQUcsQ0FBQyxhQUFhLENBQUM7O1VBRWxCLEdBQUssQ0FBQyxPQUFPLFlBQUcsQ0FBQyxBQUFTLEVBQUUsQUFBRzs7O0FBQUM7WUFDOUIsT0FBTyxHQUFHLElBQUksQ0FBQztZQUNmLGFBQWEsR0FBRyxNQUFNLENBQUM7V0FDeEIsQ0FBQzs7VUFFRixFQUFFLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQzs7VUFFNUIsT0FBTyxNQUFNO2FBQ1YsT0FBTyxVQUFDLEdBQUcsQUFBRztjQUNiLE1BQU0sQ0FBQyxTQUFTLEdBQUcsUUFBUSxDQUFDO2NBQzVCLE9BQU8sTUFBTSxDQUFDLE9BQU8sRUFBRSxlQUFlLEVBQUUsS0FBSyxDQUFDLENBQUM7YUFDaEQsQ0FBQzthQUNELElBQUksVUFBQyxHQUFHLEFBQUc7Y0FDVixNQUFNLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQztjQUM3QixNQUFNLENBQUMsT0FBTyxFQUFFLFlBQVksQ0FBQyxDQUFDO2NBQzlCLE1BQU0sQ0FBQyxTQUFTLEdBQUcsUUFBUSxDQUFDO2NBQzVCLE1BQU0sQ0FBQyxPQUFPLFVBQUMsQ0FBQyxLQUFLLEVBQUUsR0FBRyxFQUFFLEFBQUc7Z0JBQzdCLE1BQU0sQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLEVBQUUsWUFBWSxFQUFFLEtBQUssQ0FBQyxDQUFDO2VBQ2pELENBQUMsQ0FBQzthQUNKLENBQUM7YUFDRCxPQUFPLFVBQUMsR0FBRyxBQUFHO2NBQ2IsRUFBRSxDQUFDLGNBQWMsQ0FBQyxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUM7YUFDdkMsQ0FBQyxDQUFDO1NBQ047T0FDRixDQUFDO0dBQ0w7Q0FDRixDQUFDIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcInZlcnNpb25cIjogXCIyLjIuMFwiXG59IiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7dmVyc2lvbn0gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG5hbWU6ICd1bmV4cGVjdGVkLWV2ZW50ZW1pdHRlcicsXG4gIHZlcnNpb24sXG4gIGluc3RhbGxJbnRvKGV4cGVjdCkge1xuICAgIGV4cGVjdC5hZGRUeXBlKHtcbiAgICAgIGJhc2U6ICdvYmplY3QnLFxuICAgICAgbmFtZTogJ0V2ZW50RW1pdHRlcicsXG4gICAgICBpZGVudGlmeTogKG9iaikgPT5cbiAgICAgICAgb2JqICE9PSBudWxsICYmXG4gICAgICAgIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmXG4gICAgICAgIHR5cGVvZiBvYmouZW1pdCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICB0eXBlb2Ygb2JqLm9uY2UgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgdHlwZW9mIG9iai5vbiA9PT0gJ2Z1bmN0aW9uJyxcbiAgICB9KTtcblxuICAgIGV4cGVjdFxuICAgICAgLmFkZEFzc2VydGlvbihcbiAgICAgICAgJzxmdW5jdGlvbj4gW25vdF0gdG8gZW1pdCBmcm9tIDxFdmVudEVtaXR0ZXI+IDxzdHJpbmc+IDxhbnkqPicsXG4gICAgICAgIChleHBlY3QsIHN1YmplY3QsIGVlLCBldmVudE5hbWUsIC4uLnZhbHVlcykgPT4ge1xuICAgICAgICAgIGxldCBlbWl0dGVkID0gZmFsc2U7XG4gICAgICAgICAgbGV0IGVtaXR0ZWRWYWx1ZXM7XG4gICAgICAgICAgLy8gZXhwZWN0LmVycm9yTW9kZSA9ICdidWJibGUnO1xuXG4gICAgICAgICAgY29uc3Qgb25FdmVudCA9ICguLi52YWx1ZXMpID0+IHtcbiAgICAgICAgICAgIGVtaXR0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgZW1pdHRlZFZhbHVlcyA9IHZhbHVlcztcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgZWUub25jZShldmVudE5hbWUsIG9uRXZlbnQpO1xuXG4gICAgICAgICAgcmV0dXJuIGV4cGVjdFxuICAgICAgICAgICAgLnByb21pc2UoKCkgPT4ge1xuICAgICAgICAgICAgICBleHBlY3QuZXJyb3JNb2RlID0gJ2J1YmJsZSc7XG4gICAgICAgICAgICAgIHJldHVybiBleHBlY3Qoc3ViamVjdCwgJ25vdCB0byBlcnJvcicpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgZXhwZWN0LmVycm9yTW9kZSA9ICdkZWZhdWx0JztcbiAgICAgICAgICAgICAgZXhwZWN0KGVtaXR0ZWQsICdbbm90XSB0byBiZSB0cnVlJyk7XG4gICAgICAgICAgICAgIGV4cGVjdC5lcnJvck1vZGUgPSAnbmVzdGVkJztcbiAgICAgICAgICAgICAgdmFsdWVzLmZvckVhY2goKHZhbHVlLCBpZHgpID0+IHtcbiAgICAgICAgICAgICAgICBleHBlY3QoZW1pdHRlZFZhbHVlc1tpZHhdLCAnW25vdF0gdG8gc2F0aXNmeScsIHZhbHVlKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgICBlZS5yZW1vdmVMaXN0ZW5lcihldmVudE5hbWUsIG9uRXZlbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIClcbiAgICAgIC5hZGRBc3NlcnRpb24oXG4gICAgICAgICc8ZnVuY3Rpb24+IHRvIGVtaXQgd2l0aCBlcnJvciBmcm9tIDxFcnJvcj4gPEV2ZW50RW1pdHRlcj4gPHN0cmluZz4gPGFueSo+JyxcbiAgICAgICAgKGV4cGVjdCwgc3ViamVjdCwgZXJyb3IsIGVlLCBldmVudE5hbWUsIC4uLnZhbHVlcykgPT4ge1xuICAgICAgICAgIGxldCBlbWl0dGVkID0gZmFsc2U7XG4gICAgICAgICAgbGV0IGVtaXR0ZWRWYWx1ZXM7XG5cbiAgICAgICAgICBjb25zdCBvbkV2ZW50ID0gKC4uLnZhbHVlcykgPT4ge1xuICAgICAgICAgICAgZW1pdHRlZCA9IHRydWU7XG4gICAgICAgICAgICBlbWl0dGVkVmFsdWVzID0gdmFsdWVzO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBlZS5vbmNlKGV2ZW50TmFtZSwgb25FdmVudCk7XG5cbiAgICAgICAgICByZXR1cm4gZXhwZWN0XG4gICAgICAgICAgICAucHJvbWlzZSgoKSA9PiB7XG4gICAgICAgICAgICAgIGV4cGVjdC5lcnJvck1vZGUgPSAnYnViYmxlJztcbiAgICAgICAgICAgICAgcmV0dXJuIGV4cGVjdChzdWJqZWN0LCAndG8gZXJyb3Igd2l0aCcsIGVycm9yKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgIGV4cGVjdC5lcnJvck1vZGUgPSAnZGVmYXVsdCc7XG4gICAgICAgICAgICAgIGV4cGVjdChlbWl0dGVkLCAndG8gYmUgdHJ1ZScpO1xuICAgICAgICAgICAgICBleHBlY3QuZXJyb3JNb2RlID0gJ25lc3RlZCc7XG4gICAgICAgICAgICAgIHZhbHVlcy5mb3JFYWNoKCh2YWx1ZSwgaWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgZXhwZWN0KGVtaXR0ZWRWYWx1ZXNbaWR4XSwgJ3RvIHNhdGlzZnknLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgICAgZWUucmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBvbkV2ZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICApO1xuICB9LFxufTtcbiJdfQ==
