var createStandardErrorMessage = require('./createStandardErrorMessage');
var utils = require('./utils');
var magicpen = require('magicpen');
var extend = utils.extend;
var ukkonen = require('ukkonen');
var makePromise = require('./makePromise');
var addAdditionalPromiseMethods = require('./addAdditionalPromiseMethods');
var wrapPromiseIfNecessary = require('./wrapPromiseIfNecessary');
var oathbreaker = require('./oathbreaker');
var UnexpectedError = require('./UnexpectedError');
var notifyPendingPromise = require('./notifyPendingPromise');
var defaultDepth = require('./defaultDepth');
var AssertionString = require('./AssertionString');
var Context = require('./Context');
var throwIfNonUnexpectedError = require('./throwIfNonUnexpectedError');
var ensureValidUseOfParenthesesOrBrackets = require('./ensureValidUseOfParenthesesOrBrackets');
var expandAssertion = require('./expandAssertion');
var nodeJsCustomInspect = require('./nodeJsCustomInspect');

function isAssertionArg(ref) {
  var type = ref.type;

  return type.is('assertion');
}

var anyType = {
  _unexpectedType: true,
  name: 'any',
  level: 0,
  identify: function identify() {
    return true;
  },
  equal: utils.objectIs,
  inspect: function inspect(value, depth, output) {
    if (output && output.isMagicPen) {
      return output.text(value);
    } else {
      // Guard against node.js' require('util').inspect eagerly calling .inspect() on objects
      return ("type: " + (this.name));
    }
  },
  diff: function diff(actual, expected, output, diff$1, inspect) {
    return null;
  },
  typeEqualityCache: {},
  is: function is(typeOrTypeName) {
    var typeName;
    if (typeof typeOrTypeName === 'string') {
      typeName = typeOrTypeName;
    } else {
      typeName = typeOrTypeName.name;
    }

    var cachedValue = this.typeEqualityCache[typeName];
    if (typeof cachedValue !== 'undefined') {
      return cachedValue;
    }

    var result = false;
    if (this.name === typeName) {
      result = true;
    } else if (this.baseType) {
      result = this.baseType.is(typeName);
    }
    this.typeEqualityCache[typeName] = result;
    return result;
  },
};

if (nodeJsCustomInspect !== 'inspect') {
  anyType[nodeJsCustomInspect] = function () {
    return ("type: " + (this.name));
  };
}

var OR = {};
function getOrGroups(expectations) {
  var orGroups = [[]];
  expectations.forEach(function (expectation) {
    if (expectation === OR) {
      orGroups.push([]);
    } else {
      orGroups[orGroups.length - 1].push(expectation);
    }
  });
  return orGroups;
}

function evaluateGroup(expect, context, subject, orGroup, forwardedFlags) {
  return orGroup.map(function (expectation) {
    var args = Array.prototype.slice.call(expectation);
    args.unshift(subject);
    return {
      expectation: args,
      promise: makePromise(function () {
        if (typeof args[1] === 'function') {
          if (args.length > 2) {
            throw new Error(
              'expect.it(<function>) does not accept additional arguments'
            );
          } else {
            // expect.it(function (value) { ... })
            return args[1](args[0]);
          }
        } else {
          return expect._expect(context.child(), args, forwardedFlags);
        }
      }),
    };
  });
}

function writeGroupEvaluationsToOutput(output, groupEvaluations) {
  var hasOrClauses = groupEvaluations.length > 1;
  var hasAndClauses = groupEvaluations.some(function (ref) {
    var length = ref.length;

    return length > 1;
  });
  groupEvaluations.forEach(function (groupEvaluation, i) {
    if (i > 0) {
      if (hasAndClauses) {
        output.nl();
      } else {
        output.sp();
      }
      output.jsComment('or').nl();
    }

    var groupFailed = false;
    groupEvaluation.forEach(function (evaluation, j) {
      if (j > 0) {
        output.jsComment(' and').nl();
      }
      var isRejected = evaluation.promise.isRejected();
      if (isRejected && !groupFailed) {
        groupFailed = true;
        var err = evaluation.promise.reason();

        if (hasAndClauses || hasOrClauses) {
          output.error('⨯ ');
        }

        output.block(function (output) {
          output.append(err.getErrorMessage(output));
        });
      } else {
        if (isRejected) {
          output.error('⨯ ');
        } else {
          output.success('✓ ');
        }

        var expectation = evaluation.expectation;
        output.block(function (output) {
          var subject = expectation[0];
          var subjectOutput = function (output) {
            output.appendInspected(subject);
          };
          var args = expectation.slice(2);
          var argsOutput = args.map(function (arg) { return function (output) {
            output.appendInspected(arg);
          }; });
          var testDescription = expectation[1];
          createStandardErrorMessage(
            output,
            subjectOutput,
            testDescription,
            argsOutput,
            {
              subject: subject,
            }
          );
        });
      }
    });
  });
}

function createExpectIt(expect, expectations, forwardedFlags) {
  var orGroups = getOrGroups(expectations);

  function expectIt(subject, context) {
    context =
      context && typeof context === 'object' && context instanceof Context
        ? context
        : new Context();

    if (
      orGroups.length === 1 &&
      orGroups[0].length === 1 &&
      orGroups[0][0].length === 1 &&
      typeof orGroups[0][0][0] === 'function'
    ) {
      // expect.it(subject => ...)
      return oathbreaker(orGroups[0][0][0](subject));
    }

    var groupEvaluations = [];
    var promises = [];
    orGroups.forEach(function (orGroup) {
      var evaluations = evaluateGroup(
        expect,
        context,
        subject,
        orGroup,
        forwardedFlags
      );
      evaluations.forEach(function (ref) {
        var promise = ref.promise;

        promises.push(promise);
      });
      groupEvaluations.push(evaluations);
    });

    return oathbreaker(
      makePromise.settle(promises).then(function () {
        groupEvaluations.forEach(function (groupEvaluation) {
          groupEvaluation.forEach(function (ref) {
            var promise = ref.promise;

            if (
              promise.isRejected() &&
              promise.reason().errorMode === 'bubbleThrough'
            ) {
              throw promise.reason();
            }
          });
        });

        if (
          !groupEvaluations.some(function (groupEvaluation) { return groupEvaluation.every(function (ref) {
              var promise = ref.promise;

              return promise.isFulfilled();
              }); }
          )
        ) {
          expect.fail(function (output) {
            writeGroupEvaluationsToOutput(output, groupEvaluations);
          });
        }
      })
    );
  }
  expectIt._expectIt = true;
  expectIt._expectations = expectations;
  expectIt._OR = OR;
  expectIt.and = function () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    var copiedExpectations = expectations.slice();
    copiedExpectations.push(args);
    return createExpectIt(expect, copiedExpectations, forwardedFlags);
  };
  expectIt.or = function () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    var copiedExpectations = expectations.slice();
    copiedExpectations.push(OR, args);
    return createExpectIt(expect, copiedExpectations, forwardedFlags);
  };
  return expectIt;
}

var expectPrototype = {
  promise: makePromise,
  notifyPendingPromise: notifyPendingPromise,
  errorMode: 'default',
};
utils.setPrototypeOfOrExtend(expectPrototype, Function.prototype);

expectPrototype.it = function () {
  var args = [], len = arguments.length;
  while ( len-- ) args[ len ] = arguments[ len ];

  return createExpectIt(this._topLevelExpect, [args], this.flags);
};

expectPrototype.equal = function (actual, expected, depth, seen) {
  var this$1 = this;

  depth = typeof depth === 'number' ? depth : 100;
  if (depth <= 0) {
    // detect recursive loops in the structure
    seen = seen || [];
    if (seen.indexOf(actual) !== -1) {
      throw new Error('Cannot compare circular structures');
    }
    seen.push(actual);
  }

  return this.findCommonType(actual, expected).equal(actual, expected, function (a, b) { return this$1.equal(a, b, depth - 1, seen); }
  );
};

expectPrototype.inspect = function (obj, depth, outputOrFormat) {
  var this$1 = this;

  var seen = [];
  var printOutput = function (obj, currentDepth, output) {
    var objType = this$1.findTypeOf(obj);
    if (currentDepth <= 0 && objType.is('object') && !objType.is('expect.it')) {
      return output.text('...');
    }

    seen = seen || [];
    if (seen.indexOf(obj) !== -1) {
      return output.text('[Circular]');
    }

    return objType.inspect(obj, currentDepth, output, function (v, childDepth) {
      output = output.clone();
      seen.push(obj);
      if (typeof childDepth === 'undefined') {
        childDepth = currentDepth - 1;
      }
      output = printOutput(v, childDepth, output) || output;
      seen.pop();
      return output;
    });
  };

  var output =
    typeof outputOrFormat === 'string'
      ? this.createOutput(outputOrFormat)
      : outputOrFormat;
  output = output || this.createOutput();
  return (
    printOutput(
      obj,
      typeof depth === 'number' ? depth : defaultDepth,
      output
    ) || output
  );
};

if (nodeJsCustomInspect !== 'inspect') {
  expectPrototype[nodeJsCustomInspect] = expectPrototype.inspect;
}

expectPrototype.expandTypeAlternations = function (assertion) {
  var this$1 = this;

  var createPermutations = function (args, i) {
    if (i === args.length) {
      return [];
    }

    var result = [];
    args[i].forEach(function (arg) {
      var tails = createPermutations(args, i + 1);
      if (tails.length) {
        tails.forEach(function (tail) {
          result.push([arg].concat(tail));
        });
      } else if (arg.type.is('assertion')) {
        result.push([
          { type: arg.type, minimum: 1, maximum: 1 },
          { type: this$1.getType('any'), minimum: 0, maximum: Infinity } ]);
        result.push([
          { type: this$1.getType('expect.it'), minimum: 1, maximum: 1 } ]);
        if (arg.minimum === 0) {
          // <assertion?>
          result.push([]);
        }
      } else {
        result.push([arg]);
      }
    });
    return result;
  };
  var result = [];
  assertion.subject.forEach(function (subjectRequirement) {
    if (assertion.args.length) {
      createPermutations(assertion.args, 0).forEach(function (args) {
        result.push(
          extend({}, assertion, {
            subject: subjectRequirement,
            args: args,
          })
        );
      });
    } else {
      result.push(
        extend({}, assertion, {
          subject: subjectRequirement,
          args: [],
        })
      );
    }
  });
  return result;
};

expectPrototype.parseAssertion = function (assertionString) {
  var this$1 = this;

  var tokens = [];
  var nextIndex = 0;

  var parseTypeToken = function (typeToken) {
    return typeToken.split('|').map(function (typeDeclaration) {
      var matchNameAndOperator = typeDeclaration.match(
        /^([a-z_](?:|[a-z0-9_.-]*[_a-z0-9]))([+*?]|)$/i
      );
      if (!matchNameAndOperator) {
        throw new SyntaxError(
          ("Cannot parse type declaration:" + typeDeclaration)
        );
      }
      var type = this$1.getType(matchNameAndOperator[1]);
      if (!type) {
        throw new Error(
          ("Unknown type: " + (matchNameAndOperator[1]) + " in " + assertionString)
        );
      }
      var operator = matchNameAndOperator[2];
      return {
        minimum: !operator || operator === '+' ? 1 : 0,
        maximum: operator === '*' || operator === '+' ? Infinity : 1,
        type: type,
      };
    });
  };

  function hasVarargs(types) {
    return types.some(function (ref) {
      var minimum = ref.minimum;
      var maximum = ref.maximum;

      return minimum !== 1 || maximum !== 1;
    });
  }
  assertionString.replace(
    /\s*<((?:[a-z_](?:|[a-z0-9_.-]*[_a-z0-9])[?*+]?)(?:\|(?:[a-z_](?:|[a-z0-9_.-]*[_a-z0-9])[?*+]?))*)>|\s*([^<]+)/gi,
    function (ref, $1, $2, index) {
      var length = ref.length;

      if (index !== nextIndex) {
        throw new SyntaxError(
          ("Cannot parse token at index " + nextIndex + " in " + assertionString)
        );
      }
      if ($1) {
        tokens.push(parseTypeToken($1));
      } else {
        tokens.push($2.trim());
      }
      nextIndex += length;
    }
  );

  var assertion;
  if (tokens.length === 1 && typeof tokens[0] === 'string') {
    if (!this._legacyTypelessAssertionWarned) {
      console.warn(
        'The typeless expect.addAssertion syntax is deprecated and will be removed in a future update\n' +
          'Please refer to http://unexpected.js.org/api/addAssertion/'
      );
      this._legacyTypelessAssertionWarned = true;
    }
    assertion = {
      subject: parseTypeToken('any'),
      assertion: tokens[0],
      args: [parseTypeToken('any*')],
    };
  } else {
    assertion = {
      subject: tokens[0],
      assertion: tokens[1],
      args: tokens.slice(2),
    };
  }

  if (!Array.isArray(assertion.subject)) {
    throw new SyntaxError(("Missing subject type in " + assertionString));
  }
  if (typeof assertion.assertion !== 'string') {
    throw new SyntaxError(("Missing assertion in " + assertionString));
  }
  if (hasVarargs(assertion.subject)) {
    throw new SyntaxError(
      ("The subject type cannot have varargs: " + assertionString)
    );
  }
  if (assertion.args.some(function (arg) { return typeof arg === 'string'; })) {
    throw new SyntaxError('Only one assertion string is supported (see #225)');
  }

  if (assertion.args.slice(0, -1).some(hasVarargs)) {
    throw new SyntaxError(
      ("Only the last argument type can have varargs: " + assertionString)
    );
  }
  if (
    [assertion.subject]
      .concat(assertion.args.slice(0, -1))
      .some(function (argRequirements) { return argRequirements.some(function (ref) {
          var type = ref.type;

          return type.is('assertion');
          }); }
      )
  ) {
    throw new SyntaxError(
      ("Only the last argument type can be <assertion>: " + assertionString)
    );
  }

  var lastArgRequirements = assertion.args[assertion.args.length - 1] || [];
  var assertionRequirements = lastArgRequirements.filter(function (ref) {
      var type = ref.type;

      return type.is('assertion');
  }
  );

  if (assertionRequirements.length > 0 && lastArgRequirements.length > 1) {
    throw new SyntaxError(
      ("<assertion> cannot be alternated with other types: " + assertionString)
    );
  }

  if (assertionRequirements.some(function (ref) {
    var maximum = ref.maximum;

    return maximum !== 1;
  })) {
    throw new SyntaxError(
      ("<assertion+> and <assertion*> are not allowed: " + assertionString)
    );
  }
  return this.expandTypeAlternations(assertion);
};

var placeholderSplitRegexp = /(\{(?:\d+)\})/g;
var placeholderRegexp = /\{(\d+)\}/;
expectPrototype._fail = function (arg) {
  var arguments$1 = arguments;

  if (arg instanceof UnexpectedError) {
    arg._hasSerializedErrorMessage = false;
    throw arg;
  }

  if (utils.isError(arg)) {
    throw arg;
  }

  var error = new UnexpectedError(this);
  if (typeof arg === 'function') {
    error.errorMode = 'bubble';
    error.output = arg;
  } else if (arg && typeof arg === 'object') {
    if (typeof arg.message !== 'undefined') {
      error.errorMode = 'bubble';
    }
    error.output = function (output) {
      if (typeof arg.message !== 'undefined') {
        if (arg.message.isMagicPen) {
          output.append(arg.message);
        } else if (typeof arg.message === 'function') {
          arg.message.call(output, output);
        } else {
          output.text(String(arg.message));
        }
      } else {
        output.error('Explicit failure');
      }
    };
    Object.keys(arg).forEach(function (key) {
      var this$1 = this;

      var value = arg[key];
      if (key === 'diff') {
        if (typeof value === 'function' && this.parent) {
          error.createDiff = function (output, diff, inspect, equal) {
            var childOutput = this$1.createOutput(output.format);
            childOutput.inline = output.inline;
            childOutput.output = output.output;
            return value(
              childOutput,
              function (actual, expected) {
                return this$1.diff(actual, expected, childOutput.clone());
              },
              function (v, depth) { return childOutput
                  .clone()
                  .appendInspected(v, (depth || defaultDepth) - 1); },
              function (actual, expected) { return this$1.equal(actual, expected); }
            );
          };
        } else {
          error.createDiff = value;
        }
      } else if (key !== 'message') {
        error[key] = value;
      }
    }, this);
  } else {
    var placeholderArgs;
    if (arguments.length > 0) {
      placeholderArgs = new Array(arguments.length - 1);
      for (var i = 1; i < arguments.length; i += 1) {
        placeholderArgs[i - 1] = arguments$1[i];
      }
    }
    error.errorMode = 'bubble';
    error.output = function (output) {
      var message = arg ? String(arg) : 'Explicit failure';
      var tokens = message.split(placeholderSplitRegexp);
      tokens.forEach(function (token) {
        var match = placeholderRegexp.exec(token);
        if (match) {
          var index = match[1];
          if (index in placeholderArgs) {
            var placeholderArg = placeholderArgs[index];
            if (placeholderArg && placeholderArg.isMagicPen) {
              output.append(placeholderArg);
            } else {
              output.appendInspected(placeholderArg);
            }
          } else {
            output.text(match[0]);
          }
        } else {
          output.error(token);
        }
      });
    };
  }

  throw error;
};

function compareSpecificities(a, b) {
  for (var i = 0; i < Math.min(a.length, b.length); i += 1) {
    var c = b[i] - a[i];
    if (c !== 0) {
      return c;
    }
  }
  return b.length - a.length;
}

function calculateAssertionSpecificity(ref) {
  var subject = ref.subject;
  var args = ref.args;

  return [subject.type.level].concat(
    args.map(function (ref) {
      var minimum = ref.minimum;
      var maximum = ref.maximum;
      var type = ref.type;

      var bonus = minimum === 1 && maximum === 1 ? 0.5 : 0;
      return bonus + type.level;
    })
  );
}

function calculateLimits(items) {
  var minimum = 0;
  var maximum = 0;
  items.forEach(function (item) {
    minimum += item.minimum;
    maximum += item.maximum;
  });
  return {
    minimum: minimum,
    maximum: maximum,
  };
}

expectPrototype.addAssertion = function (
  patternOrPatterns,
  handler,
  childExpect
) {
  var this$1 = this;

  if (this._frozen) {
    throw new Error(
      'Cannot add an assertion to a frozen instance, please run .clone() first'
    );
  }
  var maxArguments;
  if (typeof childExpect === 'function') {
    maxArguments = 3;
  } else {
    maxArguments = 2;
  }
  if (
    arguments.length > maxArguments ||
    typeof handler !== 'function' ||
    (typeof patternOrPatterns !== 'string' && !Array.isArray(patternOrPatterns))
  ) {
    var errorMessage =
      'Syntax: expect.addAssertion(<string|array[string]>, function (expect, subject, ...) { ... });';
    if (
      (typeof handler === 'string' || Array.isArray(handler)) &&
      typeof arguments[2] === 'function'
    ) {
      errorMessage +=
        '\nAs of Unexpected 10, the syntax for adding assertions that apply only to specific\n' +
        'types has changed. See http://unexpected.js.org/api/addAssertion/';
    }
    throw new Error(errorMessage);
  }
  var patterns = Array.isArray(patternOrPatterns)
    ? patternOrPatterns
    : [patternOrPatterns];
  patterns.forEach(function (pattern) {
    if (typeof pattern !== 'string' || pattern === '') {
      throw new Error('Assertion patterns must be a non-empty string');
    } else {
      if (pattern !== pattern.trim()) {
        throw new Error(
          ("Assertion patterns can't start or end with whitespace:\n\n    " + (JSON.stringify(
            pattern
          )))
        );
      }
    }
  });

  var assertions = this.assertions;

  var defaultValueByFlag = {};
  var assertionHandlers = [];
  var maxNumberOfArgs = 0;
  patterns.forEach(function (pattern) {
    var assertionDeclarations = this$1.parseAssertion(pattern);
    assertionDeclarations.forEach(function (ref) {
      var assertion = ref.assertion;
      var args = ref.args;
      var subject = ref.subject;

      ensureValidUseOfParenthesesOrBrackets(assertion);
      var expandedAssertions = expandAssertion(assertion);
      expandedAssertions.forEach(function (ref) {
        var flags = ref.flags;
        var alternations = ref.alternations;
        var text = ref.text;

        Object.keys(flags).forEach(function (flag) {
          defaultValueByFlag[flag] = false;
        });
        maxNumberOfArgs = Math.max(
          maxNumberOfArgs,
          args.reduce(
            function (previous, ref) {
                var maximum = ref.maximum;

                return previous + (maximum === null ? Infinity : maximum);
        },
            0
          )
        );
        var limits = calculateLimits(args);
        assertionHandlers.push({
          handler: handler,
          alternations: alternations,
          flags: flags,
          subject: subject,
          args: args,
          testDescriptionString: text,
          declaration: pattern,
          expect: childExpect,
          minimum: limits.minimum,
          maximum: limits.maximum,
        });
      });
    });
  });
  if (handler.length - 2 > maxNumberOfArgs) {
    throw new Error(
      ("The provided assertion handler takes " + (handler.length - 2) + " parameters, but the type signature specifies a maximum of " + maxNumberOfArgs + ":\n\n    " + (JSON.stringify(
        patterns
      )))
    );
  }

  assertionHandlers.forEach(function (handler) {
    // Make sure that all flags are defined.
    handler.flags = extend({}, defaultValueByFlag, handler.flags);

    var assertionHandlers = assertions[handler.testDescriptionString];
    handler.specificity = calculateAssertionSpecificity(handler);
    if (!assertionHandlers) {
      assertions[handler.testDescriptionString] = [handler];
    } else {
      var i = 0;
      while (
        i < assertionHandlers.length &&
        compareSpecificities(
          handler.specificity,
          assertionHandlers[i].specificity
        ) > 0
      ) {
        i += 1;
      }
      assertionHandlers.splice(i, 0, handler);
    }
  });

  return this; // for chaining
};

expectPrototype.addType = function (type, childExpect) {
  var this$1 = this;

  if (this._frozen) {
    throw new Error(
      'Cannot add a type to a frozen instance, please run .clone() first'
    );
  }

  var baseType;
  if (
    typeof type.name !== 'string' ||
    !/^[a-z_](?:|[a-z0-9_.-]*[_a-z0-9])$/i.test(type.name)
  ) {
    throw new Error(
      'A type must be given a non-empty name and must match ^[a-z_](?:|[a-z0-9_.-]*[_a-z0-9])$'
    );
  }

  if (typeof type.identify !== 'function' && type.identify !== false) {
    throw new Error(
      ("Type " + (type.name) + " must specify an identify function or be declared abstract by setting identify to false")
    );
  }

  if (this.typeByName[type.name]) {
    throw new Error(("The type with the name " + (type.name) + " already exists"));
  }

  if (type.base) {
    baseType = this.getType(type.base);

    if (!baseType) {
      throw new Error(("Unknown base type: " + (type.base)));
    }
  } else {
    baseType = anyType;
  }

  var extendedBaseType = Object.create(baseType);
  extendedBaseType.inspect = function (value, depth, output) {
    if (!output || !output.isMagicPen) {
      throw new Error(
        'You need to pass the output to baseType.inspect() as the third parameter'
      );
    }

    return baseType.inspect(value, depth, output, function (value, depth) { return output.clone().appendInspected(value, depth); }
    );
  };

  if (nodeJsCustomInspect !== 'inspect') {
    extendedBaseType[nodeJsCustomInspect] = extendedBaseType.inspect;
  }

  extendedBaseType.diff = function (actual, expected, output) {
    if (!output || !output.isMagicPen) {
      throw new Error(
        'You need to pass the output to baseType.diff() as the third parameter'
      );
    }

    return baseType.diff(
      actual,
      expected,
      output.clone(),
      function (actual, expected) { return this$1.diff(actual, expected, output.clone()); },
      function (value, depth) { return output.clone().appendInspected(value, depth); },
      this$1.equal.bind(this$1)
    );
  };

  extendedBaseType.equal = function (actual, expected) { return baseType.equal(actual, expected, this$1.equal.bind(this$1)); };

  var extendedType = extend({}, baseType, type, {
    baseType: extendedBaseType,
  });
  var originalInspect = extendedType.inspect;

  // Prevent node.js' util.inspect from complaining about our inspect method:
  if (nodeJsCustomInspect !== 'inspect') {
    extendedType[nodeJsCustomInspect] = function () {
      return ("type: " + (type.name));
    };
  }

  extendedType.inspect = function (obj, depth, output, inspect) {
    if (arguments.length < 2 || !output || !output.isMagicPen) {
      return ("type: " + (type.name));
    } else if (childExpect) {
      var childOutput = childExpect.createOutput(output.format);
      return (
        originalInspect.call(this, obj, depth, childOutput, inspect) ||
        childOutput
      );
    } else {
      return originalInspect.call(this, obj, depth, output, inspect) || output;
    }
  };

  if (childExpect) {
    extendedType.childExpect = childExpect;
    var originalDiff = extendedType.diff;
    extendedType.diff = function (
      actual,
      expected,
      output,
      inspect,
      diff,
      equal
    ) {
      var childOutput = childExpect.createOutput(output.format);
      // Make sure that already buffered up output is preserved:
      childOutput.output = output.output;
      return (
        originalDiff.call(
          this,
          actual,
          expected,
          childOutput,
          inspect,
          diff,
          equal
        ) || output
      );
    };
  }

  if (extendedType.identify === false) {
    this.types.push(extendedType);
  } else {
    this.types.unshift(extendedType);
  }

  extendedType.level = baseType.level + 1;
  extendedType.typeEqualityCache = {};
  this.typeByName[extendedType.name] = extendedType;

  return this;
};

expectPrototype.getType = function (typeName) {
  return (
    this.typeByName[typeName] || (this.parent && this.parent.getType(typeName))
  );
};

expectPrototype.findTypeOf = function (obj) {
  return (
    utils.findFirst(
      this.types || [],
      function (type) { return type.identify && type.identify(obj); }
    ) ||
    (this.parent && this.parent.findTypeOf(obj))
  );
};

expectPrototype.findTypeOfWithParentType = function (obj, requiredParentType) {
  return (
    utils.findFirst(
      this.types || [],
      function (type) { return type.identify &&
        type.identify(obj) &&
        (!requiredParentType || type.is(requiredParentType)); }
    ) ||
    (this.parent &&
      this.parent.findTypeOfWithParentType(obj, requiredParentType))
  );
};

expectPrototype.findCommonType = function (a, b) {
  var aAncestorIndex = {};
  var current = this.findTypeOf(a);
  while (current) {
    aAncestorIndex[current.name] = current;
    current = current.baseType;
  }
  current = this.findTypeOf(b);
  while (current) {
    if (aAncestorIndex[current.name]) {
      return current;
    }
    current = current.baseType;
  }
};

expectPrototype.addStyle = function () {
  var ref;

  var args = [], len = arguments.length;
  while ( len-- ) args[ len ] = arguments[ len ];
  if (this._frozen) {
    throw new Error(
      'Cannot add a style to a frozen instance, please run .clone() first'
    );
  }
  (ref = this.output).addStyle.apply(ref, args);
  return this;
};

expectPrototype.installTheme = function () {
  var ref;

  var args = [], len = arguments.length;
  while ( len-- ) args[ len ] = arguments[ len ];
  if (this._frozen) {
    throw new Error(
      'Cannot install a theme into a frozen instance, please run .clone() first'
    );
  }
  (ref = this.output).installTheme.apply(ref, args);
  return this;
};

function getPluginName(plugin) {
  if (typeof plugin === 'function') {
    return utils.getFunctionName(plugin);
  } else {
    return plugin.name;
  }
}

expectPrototype.use = function (plugin) {
  this._assertTopLevelExpect();
  if (this._frozen) {
    throw new Error(
      'Cannot install a plugin into a frozen instance, please run .clone() first'
    );
  }
  if (
    (typeof plugin !== 'function' &&
      (typeof plugin !== 'object' ||
        typeof plugin.installInto !== 'function')) ||
    (typeof plugin.name !== 'undefined' && typeof plugin.name !== 'string')
  ) {
    throw new Error(
      'Plugins must be functions or adhere to the following interface\n' +
        '{\n' +
        '  name: <an optional plugin name>,\n' +
        '  version: <an optional semver version string>,\n' +
        '  installInto: <a function that will update the given expect instance>\n' +
        '}'
    );
  }

  var pluginName = getPluginName(plugin);

  var existingPlugin = utils.findFirst(
    this.installedPlugins,
    function (installedPlugin) {
      if (installedPlugin === plugin) {
        return true;
      } else {
        return pluginName && pluginName === getPluginName(installedPlugin);
      }
    }
  );

  if (existingPlugin) {
    if (
      existingPlugin === plugin ||
      (typeof plugin.version !== 'undefined' &&
        plugin.version === existingPlugin.version)
    ) {
      // No-op
      return this;
    } else {
      throw new Error(
        ("Another instance of the plugin '" + pluginName + "' is already installed" + (typeof existingPlugin.version !== 'undefined'
            ? (" (version " + (existingPlugin.version) + (typeof plugin.version !== 'undefined'
                  ? (", trying to install " + (plugin.version))
                  : '') + ")")
            : '') + ". Please check your node_modules folder for unmet peerDependencies.")
      );
    }
  }

  if (pluginName === 'unexpected-promise') {
    throw new Error(
      'The unexpected-promise plugin was pulled into Unexpected as of 8.5.0. This means that the plugin is no longer supported.'
    );
  }

  this.installedPlugins.push(plugin);
  if (typeof plugin === 'function') {
    plugin(this);
  } else {
    plugin.installInto(this);
  }

  return this; // for chaining
};

expectPrototype.withError = function (body, handler) { return oathbreaker(
    makePromise(body).caught(function (e) {
      throwIfNonUnexpectedError(e);
      return handler(e);
    })
  ); };

expectPrototype.installPlugin = expectPrototype.use; // Legacy alias

expectPrototype.throwAssertionNotFoundError = function (
  subject,
  testDescriptionString,
  args
) {
  var this$1 = this;

  var candidateHandlers = this.assertions[testDescriptionString];

  var instance = this;
  while (instance && !candidateHandlers) {
    candidateHandlers = instance.assertions[testDescriptionString];
    instance = instance.parent;
  }

  if (candidateHandlers) {
    this.fail({
      message: function (output) {
        var subjectOutput = function (output) {
          output.appendInspected(subject);
        };
        var argsOutput = function (output) {
          output.appendItems(args, ', ');
        };
        output
          .append(
            createStandardErrorMessage(
              output.clone(),
              subjectOutput,
              testDescriptionString,
              argsOutput
            )
          )
          .nl()
          .indentLines();
        output
          .i()
          .error('The assertion does not have a matching signature for:')
          .nl()
          .indentLines()
          .i()
          .text('<')
          .text(this$1.findTypeOf(subject).name)
          .text('>')
          .sp()
          .text(testDescriptionString);

        args.forEach(function (arg, i) {
          output.sp().text('<').text(this$1.findTypeOf(arg).name).text('>');
        });

        output.outdentLines().nl().i().text('did you mean:').indentLines().nl();
        var assertionDeclarations = Object.keys(
          candidateHandlers.reduce(function (result, ref) {
            var declaration = ref.declaration;

            result[declaration] = true;
            return result;
          }, {})
        ).sort();
        assertionDeclarations.forEach(function (declaration, i) {
          output
            .nl(i > 0 ? 1 : 0)
            .i()
            .text(declaration);
        });
        output.outdentLines();
      },
    });
  }

  var assertionsWithScore = [];
  var assertionStrings = [];
  instance = this;
  while (instance) {
    assertionStrings.push.apply(assertionStrings, Object.keys(instance.assertions));
    instance = instance.parent;
  }

  var compareAssertions = function (a, b) {
    var aAssertion = this$1.lookupAssertionRule(subject, a, args);
    var bAssertion = this$1.lookupAssertionRule(subject, b, args);
    if (!aAssertion && !bAssertion) {
      return 0;
    }
    if (aAssertion && !bAssertion) {
      return -1;
    }
    if (!aAssertion && bAssertion) {
      return 1;
    }

    return compareSpecificities(aAssertion.specificity, bAssertion.specificity);
  };

  assertionStrings.forEach(function (assertionString) {
    var score = ukkonen(testDescriptionString, assertionString);

    assertionsWithScore.push({
      assertion: assertionString,
      score: score,
    });
  });

  var bestMatch = assertionsWithScore
    .sort(function (a, b) {
      var c = a.score - b.score;
      if (c !== 0) {
        return c;
      }

      if (a.assertion < b.assertion) {
        return -1;
      } else {
        return 1;
      }
    })
    .slice(0, 10)
    .filter(function (ref, i, arr) {
      var score = ref.score;

      return Math.abs(score - arr[0].score) <= 2;
  })
    .sort(function (a, b) {
      var c = compareAssertions(a.assertion, b.assertion);
      if (c !== 0) {
        return c;
      }

      return a.score - b.score;
    })[0];

  this.fail({
    errorMode: 'bubbleThrough',
    message: function message(output) {
      output
        .error("Unknown assertion '")
        .jsString(testDescriptionString)
        .error("', did you mean: '")
        .jsString(bestMatch.assertion)
        .error("'");
    },
  });
};

expectPrototype.lookupAssertionRule = function (
  subject,
  testDescriptionString,
  args,
  requireAssertionSuffix
) {
  var this$1 = this;

  if (typeof testDescriptionString !== 'string') {
    throw new Error(
      'The expect function requires the second parameter to be a string or an expect.it.'
    );
  }
  var handlers;
  var instance = this;
  while (instance) {
    var instanceHandlers = instance.assertions[testDescriptionString];
    if (instanceHandlers) {
      handlers = handlers
        ? handlers.concat(instanceHandlers)
        : instanceHandlers;
    }
    instance = instance.parent;
  }
  if (!handlers) {
    return null;
  }
  var cachedTypes = {};

  var findTypeOf = function (value, key) {
    var type = cachedTypes[key];
    if (!type) {
      type = this$1.findTypeOf(value);
      cachedTypes[key] = type;
    }
    return type;
  };

  var matches = function (value, assertionType, key, relaxed) {
    if (assertionType.is('assertion') && typeof value === 'string') {
      return true;
    }

    if (relaxed) {
      if (assertionType.identify === false) {
        return this$1.types.some(
          function (type) { return type.identify && type.is(assertionType) && type.identify(value); }
        );
      }
      return assertionType.identify(value);
    } else {
      return findTypeOf(value, key).is(assertionType);
    }
  };

  function matchesHandler(handler, relaxed) {
    if (!matches(subject, handler.subject.type, 'subject', relaxed)) {
      return false;
    }
    if (requireAssertionSuffix && !handler.args.some(isAssertionArg)) {
      return false;
    }

    if (args.length < handler.minimum || handler.maximum < args.length) {
      return false;
    } else if (args.length === 0 && handler.maximum === 0) {
      return true;
    }

    var lastRequirement = handler.args[handler.args.length - 1];
    return args.every(function (arg, i) {
      if (i < handler.args.length - 1) {
        return matches(arg, handler.args[i].type, i, relaxed);
      } else {
        return matches(arg, lastRequirement.type, i, relaxed);
      }
    });
  }

  var j, handler;
  for (j = 0; j < handlers.length; j += 1) {
    handler = handlers[j];
    if (matchesHandler(handler)) {
      return handler;
    }
  }
  for (j = 0; j < handlers.length; j += 1) {
    handler = handlers[j];
    if (matchesHandler(handler, true)) {
      return handler;
    }
  }

  return null;
};

expectPrototype._assertTopLevelExpect = function () {
  // Cannot use this !== this._topLevelExpect due to https://github.com/unexpectedjs/unexpected/issues/631
  if (this.flags) {
    throw new Error('This method only works on the top level expect function');
  }
};

expectPrototype._assertWrappedExpect = function () {
  // Cannot use this === this._topLevelExpect due to https://github.com/unexpectedjs/unexpected/issues/631
  if (!this.flags) {
    throw new Error(
      'This method only works on the expect function handed to an assertion'
    );
  }
};

expectPrototype.setErrorMessage = function (err) {
  err.serializeMessage(this.outputFormat());
};

expectPrototype._createWrappedExpect = function (
  assertionRule,
  subject,
  args,
  testDescriptionString,
  context,
  forwardedFlags
) {
  var flags = extend({}, forwardedFlags, assertionRule.flags);
  var parentExpect = this;

  function wrappedExpect(subject, testDescriptionString) {
    var arguments$1 = arguments;

    if (arguments.length === 0) {
      throw new Error('The expect function requires at least one parameter.');
    } else if (arguments.length === 1) {
      return addAdditionalPromiseMethods(
        makePromise.resolve(subject),
        wrappedExpect,
        subject
      );
    } else if (typeof testDescriptionString === 'function') {
      wrappedExpect.errorMode = 'nested';
      return wrappedExpect.withError(
        function () { return testDescriptionString(subject); },
        function (err) {
          wrappedExpect.fail(err);
        }
      );
    }
    testDescriptionString = utils.forwardFlags(testDescriptionString, flags);

    var args = new Array(arguments.length - 2);
    for (var i = 2; i < arguments.length; i += 1) {
      args[i - 2] = arguments$1[i];
    }
    return wrappedExpect._callInNestedContext(function () { return parentExpect._executeExpect(
        context.child(),
        subject,
        testDescriptionString,
        args,
        wrappedExpect.flags
      ); }
    );
  }

  utils.setPrototypeOfOrExtend(wrappedExpect, this);

  wrappedExpect.context = context;
  wrappedExpect.execute = wrappedExpect;
  wrappedExpect.alternations = assertionRule.alternations;
  wrappedExpect.flags = flags;
  wrappedExpect.subject = subject;
  wrappedExpect.testDescription = testDescriptionString;
  wrappedExpect.args = args;
  wrappedExpect.assertionRule = assertionRule;

  wrappedExpect.subjectOutput = function (output) {
    output.appendInspected(subject);
  };
  wrappedExpect.argsOutput = args.map(function (arg, i) {
    var argRule = wrappedExpect.assertionRule.args[i];
    if (
      typeof arg === 'string' &&
      ((argRule && argRule.type.is('assertion')) ||
        wrappedExpect._getAssertionIndices().indexOf(i) >= 0)
    ) {
      return new AssertionString(utils.forwardFlags(arg, flags));
    }

    return function (output) {
      output.appendInspected(arg);
    };
  });

  return wrappedExpect;
};

expectPrototype._executeExpect = function (
  context,
  subject,
  testDescriptionString,
  args,
  forwardedFlags
) {
  if (forwardedFlags) {
    testDescriptionString = utils.forwardFlags(
      testDescriptionString,
      forwardedFlags
    );
  }
  var assertionRule = this.lookupAssertionRule(
    subject,
    testDescriptionString,
    args
  );

  if (!assertionRule) {
    var tokens = testDescriptionString.split(' ');
    // eslint-disable-next-line no-labels
    OUTER: for (var n = tokens.length - 1; n > 0; n -= 1) {
      var prefix = tokens.slice(0, n).join(' ');
      var remainingTokens = tokens.slice(n);
      var argsWithAssertionPrepended = [remainingTokens.join(' ')].concat(
        args
      );
      assertionRule = this.lookupAssertionRule(
        subject,
        prefix,
        argsWithAssertionPrepended,
        true
      );
      if (assertionRule) {
        // Found the longest prefix of the string that yielded a suitable assertion for the given subject and args
        // To avoid bogus error messages when shifting later (#394) we require some prefix of the remaining tokens
        // to be a valid assertion name:
        for (var i = 1; i < remainingTokens.length; i += 1) {
          if (
            Object.prototype.hasOwnProperty.call(
              this.assertions,
              remainingTokens.slice(0, i + 1).join(' ')
            )
          ) {
            testDescriptionString = prefix;
            args = argsWithAssertionPrepended;
            // eslint-disable-next-line no-labels
            break OUTER;
          }
        }
      }
    }
    if (!assertionRule) {
      this.throwAssertionNotFoundError(subject, testDescriptionString, args);
    }
  }

  if (assertionRule.expect && assertionRule.expect !== this._topLevelExpect) {
    return assertionRule.expect._expect(context, [
      subject,
      testDescriptionString ].concat( args ));
  }

  var wrappedExpect = this._createWrappedExpect(
    assertionRule,
    subject,
    args,
    testDescriptionString,
    context,
    forwardedFlags
  );

  return oathbreaker(assertionRule.handler.apply(assertionRule, [ wrappedExpect, subject ].concat( args )));
};

expectPrototype._expect = function (context, args, forwardedFlags) {
  var this$1 = this;

  var subject = args[0];
  var testDescriptionString = args[1];

  if (args.length < 2) {
    throw new Error('The expect function requires at least two parameters.');
  } else if (typeof testDescriptionString === 'function') {
    return this.withError(
      function () { return testDescriptionString(subject); },
      function (err) {
        this$1.fail(err);
      }
    );
  }

  try {
    var result = this._executeExpect(
      context,
      subject,
      testDescriptionString,
      Array.prototype.slice.call(args, 2),
      forwardedFlags
    );
    if (utils.isPromise(result)) {
      result = wrapPromiseIfNecessary(result);
      if (result.isPending()) {
        result = result.then(undefined, function (e) {
          if (e && e._isUnexpected && context.level === 0) {
            this$1.setErrorMessage(e);
          }
          throw e;
        });
        this.notifyPendingPromise(result);
      }
    } else {
      result = makePromise.resolve(result);
    }
    return addAdditionalPromiseMethods(result, this, subject);
  } catch (e) {
    if (e && e._isUnexpected) {
      var newError = e;
      if (typeof mochaPhantomJS !== 'undefined') {
        newError = e.clone();
      }
      if (context.level === 0) {
        this.setErrorMessage(newError);
      }
      throw newError;
    }
    throw e;
  }
};

expectPrototype.diff = function (
  a,
  b,
  output,
  recursions,
  seen
) {
  var this$1 = this;
  if ( output === void 0 ) output = this.createOutput();

  var maxRecursions = 100;
  recursions = typeof recursions === 'number' ? recursions : maxRecursions;
  if (recursions <= 0) {
    // detect recursive loops in the structure
    seen = seen || [];
    if (seen.indexOf(a) !== -1) {
      throw new Error('Cannot compare circular structures');
    }
    seen.push(a);
  }

  return this.findCommonType(a, b).diff(
    a,
    b,
    output,
    function (actual, expected) { return this$1.diff(actual, expected, output.clone(), recursions - 1, seen); },
    function (v, depth) { return output.clone().appendInspected(v, depth); },
    function (actual, expected) { return this$1.equal(actual, expected); }
  );
};

expectPrototype.toString = function () {
  var assertions = this.assertions;

  var seen = {};
  var declarations = [];
  var pen = magicpen();
  Object.keys(assertions)
    .sort()
    .forEach(function (key) {
      assertions[key].forEach(function (ref) {
        var declaration = ref.declaration;

        if (!seen[declaration]) {
          declarations.push(declaration);
          seen[declaration] = true;
        }
      });
    });

  declarations.forEach(function (declaration) {
    pen.text(declaration).nl();
  });
  return pen.toString();
};

expectPrototype.clone = function () {
  this._assertTopLevelExpect();
  var clonedAssertions = {};
  Object.keys(this.assertions).forEach(function (assertion) {
    clonedAssertions[assertion] = [].concat(this.assertions[assertion]);
  }, this);
  var expect = createTopLevelExpect({
    assertions: clonedAssertions,
    types: [].concat(this.types),
    typeByName: extend({}, this.typeByName),
    output: this.output.clone(),
    format: this.outputFormat(),
    installedPlugins: [].concat(this.installedPlugins),
  });
  // Install the hooks:
  this.installedHooks.forEach(function (hook) {
    expect.hook(hook);
  });
  // expect._expect = this._expect;
  // Make sure that changes to the parent's preferredWidth doesn't propagate:
  expect.output.preferredWidth = this.output.preferredWidth;
  return expect;
};

expectPrototype.child = function () {
  this._assertTopLevelExpect();
  var childExpect = createTopLevelExpect({
    assertions: {},
    types: [],
    typeByName: {},
    output: this.output.clone(),
    format: this.outputFormat(),
    installedPlugins: [],
  });
  var parent = (childExpect.parent = this);

  childExpect.exportAssertion = function (testDescription, handler) {
    parent.addAssertion(testDescription, handler, childExpect);
    return this;
  };
  childExpect.exportType = function (type) {
    if (childExpect.getType(type.name) !== type) {
      childExpect.addType(type);
    }

    parent.addType(type, childExpect);
    return this;
  };
  childExpect.exportStyle = function (name, handler, allowRedefinition) {
    parent.addStyle(
      name,
      function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var childOutput = childExpect.createOutput(this.format);
        this.append(handler.call.apply(handler, [ childOutput ].concat( args )) || childOutput);
      },
      allowRedefinition
    );
    return this;
  };
  return childExpect;
};

expectPrototype.freeze = function () {
  this._assertTopLevelExpect();
  this._frozen = true;
  return this;
};

expectPrototype.outputFormat = function (format) {
  this._assertTopLevelExpect();
  if (typeof format === 'undefined') {
    return this._outputFormat;
  } else {
    this._outputFormat = format;
    return this;
  }
};

expectPrototype.createOutput = function (format) {
  var that = this;
  var output = this.output.clone(format || 'text');
  output.addStyle('appendInspected', function (value, depth) {
    this.append(that.inspect(value, depth, this.clone()));
  });
  return output;
};

expectPrototype.hook = function (fn) {
  this._assertTopLevelExpect();
  if (this._frozen) {
    throw new Error(
      'Cannot install a hook into a frozen instance, please run .clone() first'
    );
  }
  this.installedHooks.push(fn);
  this._expect = fn(this._expect.bind(this));
};

// This is not super elegant, but wrappedExpect.fail was different:
expectPrototype.fail = function () {
  var this$1 = this;
  var ref;

  var args = [], len = arguments.length;
  while ( len-- ) args[ len ] = arguments[ len ];
  // Cannot use this !== this._topLevelExpect due to https://github.com/unexpectedjs/unexpected/issues/631
  if (this.flags) {
    this._callInNestedContext(function () {
      var ref;

      (ref = this$1._topLevelExpect)._fail.apply(ref, args);
    });
  } else {
    try {
      (ref = this)._fail.apply(ref, args);
    } catch (e) {
      if (e && e._isUnexpected) {
        this.setErrorMessage(e);
      }
      throw e;
    }
  }
};

function lookupAssertionsInParentChain(assertionString, expect) {
  var assertions = [];
  for (var instance = expect; instance; instance = instance.parent) {
    if (instance.assertions[assertionString]) {
      assertions.push.apply(assertions, instance.assertions[assertionString]);
    }
  }
  return assertions;
}

function findSuffixAssertions(assertionString, expect) {
  if (typeof assertionString !== 'string') {
    return null;
  }
  var straightforwardAssertions = lookupAssertionsInParentChain(
    assertionString,
    expect
  );
  if (straightforwardAssertions.length > 0) {
    return straightforwardAssertions;
  }
  var tokens = assertionString.split(' ');
  for (var n = tokens.length - 1; n > 0; n -= 1) {
    var suffix = tokens.slice(n).join(' ');
    var suffixAssertions = lookupAssertionsInParentChain(suffix, expect);
    if (
      findSuffixAssertions(tokens.slice(0, n).join(' '), expect) &&
      suffixAssertions.length > 0
    ) {
      return suffixAssertions;
    }
  }
  return null;
}

expectPrototype.standardErrorMessage = function (output, options) {
  var this$1 = this;

  this._assertWrappedExpect();
  options = typeof options === 'object' ? options : {};

  if ('omitSubject' in output) {
    options.subject = this.subject;
  }

  if (options && options.compact) {
    options.compactSubject = function (output) {
      output.jsFunctionName(this$1.subjectType.name);
    };
  }
  return createStandardErrorMessage(
    output,
    this.subjectOutput,
    this.testDescription,
    this.argsOutput,
    options
  );
};

expectPrototype._callInNestedContext = function (callback) {
  var this$1 = this;

  this._assertWrappedExpect();
  try {
    var result = oathbreaker(callback());
    if (utils.isPromise(result)) {
      result = wrapPromiseIfNecessary(result);
      if (result.isPending()) {
        result = result.then(undefined, function (e) {
          if (e && e._isUnexpected) {
            var wrappedError = new UnexpectedError(this$1, e);
            wrappedError.originalError = e.originalError;
            throw wrappedError;
          }
          throw e;
        });
      }
    } else {
      result = makePromise.resolve(result);
    }
    return addAdditionalPromiseMethods(result, this.execute, this.subject);
  } catch (e) {
    if (e && e._isUnexpected) {
      var wrappedError = new UnexpectedError(this, e);
      wrappedError.originalError = e.originalError;
      throw wrappedError;
    }
    throw e;
  }
};

expectPrototype.shift = function (subject, assertionIndex) {
  var this$1 = this;
  var ref;

  this._assertWrappedExpect();
  if (arguments.length <= 1) {
    if (arguments.length === 0) {
      subject = this.subject;
    }
    assertionIndex = -1;
    for (var i = 0; i < this.assertionRule.args.length; i += 1) {
      var type = this.assertionRule.args[i].type;
      if (type.is('assertion') || type.is('expect.it')) {
        assertionIndex = i;
        break;
      }
    }
  } else if (arguments.length === 3) {
    // The 3-argument syntax for wrappedExpect.shift is deprecated, please omit the first (expect) arg
    subject = arguments[1];
    assertionIndex = arguments[2];
  }

  if (assertionIndex !== -1) {
    var args = this.args.slice(0, assertionIndex);
    var rest = this.args.slice(assertionIndex);
    var nextArgumentType = this.findTypeOf(rest[0]);
    if (arguments.length > 1) {
      // Legacy
      this.argsOutput = function (output) {
        args.forEach(function (arg, index) {
          if (index > 0) {
            output.text(', ');
          }
          output.appendInspected(arg);
        });

        if (args.length > 0) {
          output.sp();
        }
        if (nextArgumentType.is('string')) {
          output.error(rest[0]);
        } else if (rest.length > 0) {
          output.appendInspected(rest[0]);
        }
        if (rest.length > 1) {
          output.sp();
        }
        rest.slice(1).forEach(function (arg, index) {
          if (index > 0) {
            output.text(', ');
          }
          output.appendInspected(arg);
        });
      };
    }
    if (nextArgumentType.is('expect.it')) {
      return this.withError(
        function () { return rest[0](subject); },
        function (err) {
          this$1.fail(err);
        }
      );
    } else if (nextArgumentType.is('string')) {
      return (ref = this).execute.apply(ref, [ subject ].concat( rest ));
    } else {
      return subject;
    }
  } else {
    // No assertion to delegate to. Provide the new subject as the fulfillment value:
    return subject;
  }
};

expectPrototype._getSubjectType = function () {
  this._assertWrappedExpect();
  return this.findTypeOfWithParentType(
    this.subject,
    this.assertionRule.subject.type
  );
};

expectPrototype._getArgTypes = function (index) {
  var this$1 = this;

  this._assertWrappedExpect();
  var lastIndex = this.assertionRule.args.length - 1;
  return this.args.map(function (arg, index) {
    return this$1.findTypeOfWithParentType(
      arg,
      this$1.assertionRule.args[Math.min(index, lastIndex)].type
    );
  });
};

expectPrototype._getAssertionIndices = function () {
  this._assertWrappedExpect();
  if (!this._assertionIndices) {
    var assertionIndices = [];
    var args = this.args;
    var currentAssertionRule = this.assertionRule;
    var offset = 0;
    // eslint-disable-next-line no-labels
    OUTER: while (true) {
      if (
        currentAssertionRule.args.length > 1 &&
        isAssertionArg(
          currentAssertionRule.args[currentAssertionRule.args.length - 2]
        )
      ) {
        assertionIndices.push(offset + currentAssertionRule.args.length - 2);
        var suffixAssertions = findSuffixAssertions(
          args[offset + currentAssertionRule.args.length - 2],
          this
        );
        if (suffixAssertions) {
          for (var i = 0; i < suffixAssertions.length; i += 1) {
            if (suffixAssertions[i].args.some(isAssertionArg)) {
              offset += currentAssertionRule.args.length - 1;
              currentAssertionRule = suffixAssertions[i];
              // eslint-disable-next-line no-labels
              continue OUTER;
            }
          }
        }
      }
      // No further assertions found,
      break;
    }
    this._assertionIndices = assertionIndices;
  }
  return this._assertionIndices;
};

Object.defineProperty(expectPrototype, 'subjectType', {
  enumerable: true,
  get: function get() {
    this._assertWrappedExpect();
    return this._getSubjectType();
  },
});

Object.defineProperty(expectPrototype, 'argTypes', {
  enumerable: true,
  get: function get() {
    this._assertWrappedExpect();
    return this._getArgTypes();
  },
});

function createTopLevelExpect(ref) {
  if ( ref === void 0 ) ref = {};
  var assertions = ref.assertions; if ( assertions === void 0 ) assertions = {};
  var typeByName = ref.typeByName; if ( typeByName === void 0 ) typeByName = { any: anyType };
  var types = ref.types; if ( types === void 0 ) types = [anyType];
  var output = ref.output;
  var format = ref.format; if ( format === void 0 ) format = magicpen.defaultFormat;
  var installedPlugins = ref.installedPlugins; if ( installedPlugins === void 0 ) installedPlugins = [];

  var expect = function () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    return expect._expect(new Context(), args);
  };
  utils.setPrototypeOfOrExtend(expect, expectPrototype);

  if (!output) {
    output = magicpen();
    output.inline = false;
    output.diff = false;
  }
  return extend(expect, {
    _topLevelExpect: expect,
    _outputFormat: format,
    assertions: assertions,
    typeByName: typeByName,
    installedPlugins: installedPlugins,
    installedHooks: [],
    types: types,
    output: output,
  });
}

module.exports = createTopLevelExpect;
