var extend = require('./utils').extend;

function isFlag(token) {
  return token.slice(0, 1) === '[' && token.slice(-1) === ']';
}
function isAlternation(token) {
  return token.slice(0, 1) === '(' && token.slice(-1) === ')';
}
function removeEmptyStrings(texts) {
  return texts.filter(function (text) { return text !== ''; });
}
function createPermutations(tokens, index) {
  if (index === tokens.length) {
    return [{ text: '', flags: {}, alternations: [] }];
  }

  var token = tokens[index];
  var tail = createPermutations(tokens, index + 1);
  if (isFlag(token)) {
    var flag = token.slice(1, -1);
    return tail
      .map(function (pattern) {
        var flags = {};
        flags[flag] = true;
        return {
          text: (flag + " " + (pattern.text)),
          flags: extend(flags, pattern.flags),
          alternations: pattern.alternations,
        };
      })
      .concat(
        tail.map(function (pattern) {
          var flags = {};
          flags[flag] = false;
          return {
            text: pattern.text,
            flags: extend(flags, pattern.flags),
            alternations: pattern.alternations,
          };
        })
      );
  } else if (isAlternation(token)) {
    return token
      .substr(1, token.length - 2) // Remove parentheses
      .split(/\|/)
      .reduce(
        function (result, alternation) { return result.concat(
            tail.map(function (ref) {
              var text = ref.text;
              var flags = ref.flags;
              var alternations = ref.alternations;

              return ({
              // Make sure that an empty alternation doesn't produce two spaces:
              text: alternation ? alternation + text : text.replace(/^ /, ''),

              flags: flags,
              alternations: [alternation ].concat( alternations),
            });
            })
          ); },
        []
      );
  } else {
    return tail.map(function (ref) {
      var text = ref.text;
      var flags = ref.flags;
      var alternations = ref.alternations;

      return ({
      text: token + text,
      flags: flags,
      alternations: alternations,
    });
    });
  }
}

function expandAssertion(pattern) {
  pattern = pattern.replace(/(\[[^\]]+\]) ?/g, '$1');
  var splitRegex = /\[[^\]]+\]|\([^)]+\)/g;
  var tokens = [];
  var m;
  var lastIndex = 0;
  while ((m = splitRegex.exec(pattern))) {
    tokens.push(pattern.slice(lastIndex, m.index));
    tokens.push(pattern.slice(m.index, splitRegex.lastIndex));
    lastIndex = splitRegex.lastIndex;
  }
  tokens.push(pattern.slice(lastIndex));
  tokens = removeEmptyStrings(tokens);
  var permutations = createPermutations(tokens, 0);
  permutations.forEach(function (permutation) {
    permutation.text = permutation.text.trim();
    if (permutation.text === '') {
      // This can only happen if the pattern only contains flags
      throw new Error('Assertion patterns must not only contain flags');
    }
  });
  return permutations;
}

module.exports = expandAssertion;
